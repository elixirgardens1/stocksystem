SCRIPT  /home/ryan/.config/nvim/plugged/ale/autoload/ale/fix.vim
Sourced 1 time
Total time:   0.000359
 Self time:   0.000359

count  total (s)   self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: Functions for fixing code with programs, or other means.
                            
    1              0.000007 let g:ale_fix_on_save_ignore = get(g:, 'ale_fix_on_save_ignore', {})
    1              0.000003 let g:ale_filename_mappings = get(g:, 'ale_filename_mappings', {})
                            
                            " Apply fixes queued up for buffers which may be hidden.
                            " Vim doesn't let you modify hidden buffers.
    1              0.000002 function! ale#fix#ApplyQueuedFixes(buffer) abort
                                let l:data = get(g:ale_fix_buffer_data, a:buffer, {'done': 0})
                            
                                if !l:data.done || (!ale#util#HasBuflineApi() && a:buffer isnot bufnr(''))
                                    return
                                endif
                            
                                call remove(g:ale_fix_buffer_data, a:buffer)
                            
                                try
                                    if l:data.changes_made
                                        let l:new_lines = ale#util#SetBufferContents(a:buffer, l:data.output)
                            
                                        if l:data.should_save
                                            if a:buffer is bufnr('')
                                                if empty(&buftype)
                                                    noautocmd :w!
                                                else
                                                    set nomodified
                                                endif
                                            else
                                                call writefile(l:new_lines, expand('#' . a:buffer . ':p')) " no-custom-checks
                                                call setbufvar(a:buffer, '&modified', 0)
                                            endif
                                        endif
                                    endif
                                catch /E21/
                                    " If we cannot modify the buffer now, try again later.
                                    let g:ale_fix_buffer_data[a:buffer] = l:data
                            
                                    return
                                endtry
                            
                                if l:data.should_save
                                    let l:should_lint = ale#Var(a:buffer, 'fix_on_save')
                                    \   && ale#Var(a:buffer, 'lint_on_save')
                                else
                                    let l:should_lint = l:data.changes_made
                                endif
                            
                                silent doautocmd <nomodeline> User ALEFixPost
                            
                                " If ALE linting is enabled, check for problems with the file again after
                                " fixing problems.
                                if g:ale_enabled
                                \&& l:should_lint
                                \&& !ale#events#QuitRecently(a:buffer)
                                    call ale#Queue(0, l:data.should_save ? 'lint_file' : '')
                                endif
                            endfunction
                            
    1              0.000001 function! ale#fix#ApplyFixes(buffer, output) abort
                                let l:data = g:ale_fix_buffer_data[a:buffer]
                                let l:data.output = a:output
                                let l:data.changes_made = l:data.lines_before !=# l:data.output " no-custom-checks
                                let l:data.done = 1
                            
                                call ale#command#RemoveManagedFiles(a:buffer)
                            
                                if !bufexists(a:buffer)
                                    " Remove the buffer data when it doesn't exist.
                                    call remove(g:ale_fix_buffer_data, a:buffer)
                                endif
                            
                                if l:data.changes_made && bufexists(a:buffer)
                                    let l:lines = getbufline(a:buffer, 1, '$')
                            
                                    if l:data.lines_before != l:lines
                                        call remove(g:ale_fix_buffer_data, a:buffer)
                            
                                        if !l:data.ignore_file_changed_errors
                                            execute 'echoerr ''The file was changed before fixing finished'''
                                        endif
                            
                                        return
                                    endif
                                endif
                            
                                " We can only change the lines of a buffer which is currently open,
                                " so try and apply the fixes to the current buffer.
                                call ale#fix#ApplyQueuedFixes(a:buffer)
                            endfunction
                            
    1              0.000005 function! s:HandleExit(job_info, buffer, job_output, data) abort
                                let l:buffer_info = get(g:ale_fix_buffer_data, a:buffer, {})
                            
                                if empty(l:buffer_info)
                                    return
                                endif
                            
                                if a:job_info.read_temporary_file
                                    let l:output = !empty(a:data.temporary_file)
                                    \   ?  readfile(a:data.temporary_file)
                                    \   : []
                                else
                                    let l:output = a:job_output
                                endif
                            
                                let l:ProcessWith = get(a:job_info, 'process_with', v:null)
                            
                                " Post-process the output with a function if we have one.
                                if l:ProcessWith isnot v:null
                                    let l:output = call(l:ProcessWith, [a:buffer, l:output])
                                endif
                            
                                " Use the output of the job for changing the file if it isn't empty,
                                " otherwise skip this job and use the input from before.
                                "
                                " We'll use the input from before for chained commands.
                                if !empty(split(join(l:output)))
                                    let l:input = l:output
                                else
                                    let l:input = a:job_info.input
                                endif
                            
                                call s:RunFixer({
                                \   'buffer': a:buffer,
                                \   'input': l:input,
                                \   'callback_list': a:job_info.callback_list,
                                \   'callback_index': a:job_info.callback_index + 1,
                                \})
                            endfunction
                            
    1              0.000003 function! s:RunJob(result, options) abort
                                if ale#command#IsDeferred(a:result)
                                    let a:result.result_callback = {x -> s:RunJob(x, a:options)}
                            
                                    return
                                endif
                            
                                let l:buffer = a:options.buffer
                                let l:input = a:options.input
                                let l:fixer_name = a:options.fixer_name
                            
                                if a:result is 0 || type(a:result) is v:t_list
                                    if type(a:result) is v:t_list
                                        let l:input = a:result
                                    endif
                            
                                    call s:RunFixer({
                                    \   'buffer': l:buffer,
                                    \   'input': l:input,
                                    \   'callback_index': a:options.callback_index + 1,
                                    \   'callback_list': a:options.callback_list,
                                    \})
                            
                                    return
                                endif
                            
                                let l:command = get(a:result, 'command', '')
                            
                                if empty(l:command)
                                    " If the command is empty, skip to the next item.
                                    call s:RunFixer({
                                    \   'buffer': l:buffer,
                                    \   'input': l:input,
                                    \   'callback_index': a:options.callback_index,
                                    \   'callback_list': a:options.callback_list,
                                    \})
                            
                                    return
                                endif
                            
                                let l:read_temporary_file = get(a:result, 'read_temporary_file', 0)
                                let l:read_buffer = get(a:result, 'read_buffer', 1)
                                let l:output_stream = get(a:result, 'output_stream', 'stdout')
                                let l:cwd = get(a:result, 'cwd', v:null)
                            
                                if l:read_temporary_file
                                    let l:output_stream = 'none'
                                endif
                            
                                let l:Callback = function('s:HandleExit', [{
                                \   'input': l:input,
                                \   'callback_index': a:options.callback_index,
                                \   'callback_list': a:options.callback_list,
                                \   'process_with': get(a:result, 'process_with', v:null),
                                \   'read_temporary_file': l:read_temporary_file,
                                \}])
                                let l:run_result = ale#command#Run(l:buffer, l:command, l:Callback, {
                                \   'output_stream': l:output_stream,
                                \   'executable': '',
                                \   'read_buffer': l:read_buffer,
                                \   'input': l:input,
                                \   'log_output': 0,
                                \   'cwd': l:cwd,
                                \   'filename_mappings': ale#GetFilenameMappings(l:buffer, l:fixer_name),
                                \})
                            
                                if empty(l:run_result)
                                    call s:RunFixer({
                                    \   'buffer': l:buffer,
                                    \   'input': l:input,
                                    \   'callback_index': a:options.callback_index + 1,
                                    \   'callback_list': a:options.callback_list,
                                    \})
                                endif
                            endfunction
                            
    1              0.000001 function! s:RunFixer(options) abort
                                let l:buffer = a:options.buffer
                                let l:input = a:options.input
                                let l:index = a:options.callback_index
                            
                                if len(a:options.callback_list) <= l:index
                                    call ale#fix#ApplyFixes(l:buffer, l:input)
                            
                                    return
                                endif
                            
                                let [l:fixer_name, l:Function] = a:options.callback_list[l:index]
                            
                                " Record new jobs started as fixer jobs.
                                call setbufvar(l:buffer, 'ale_job_type', 'fixer')
                            
                                " Regular fixer commands accept (buffer, [input])
                                let l:result = ale#util#FunctionArgCount(l:Function) == 1
                                \   ? call(l:Function, [l:buffer])
                                \   : call(l:Function, [l:buffer, copy(l:input)])
                            
                                call s:RunJob(l:result, {
                                \   'buffer': l:buffer,
                                \   'input': l:input,
                                \   'callback_list': a:options.callback_list,
                                \   'callback_index': l:index,
                                \   'fixer_name': l:fixer_name,
                                \})
                            endfunction
                            
    1              0.000002 function! s:AddSubCallbacks(full_list, callbacks) abort
                                if type(a:callbacks) is v:t_string
                                    call add(a:full_list, a:callbacks)
                                elseif type(a:callbacks) is v:t_list
                                    call extend(a:full_list, a:callbacks)
                                else
                                    return 0
                                endif
                            
                                return 1
                            endfunction
                            
    1              0.000001 function! s:IgnoreFixers(callback_list, filetype, config) abort
                                if type(a:config) is v:t_list
                                    let l:ignore_list = a:config
                                else
                                    let l:ignore_list = []
                            
                                    for l:part in split(a:filetype , '\.')
                                        call extend(l:ignore_list, get(a:config, l:part, []))
                                    endfor
                                endif
                            
                                call filter(a:callback_list, 'index(l:ignore_list, v:val) < 0')
                            endfunction
                            
    1              0.000001 function! s:GetCallbacks(buffer, fixing_flag, fixers) abort
                                if len(a:fixers)
                                    let l:callback_list = a:fixers
                                elseif type(get(b:, 'ale_fixers')) is v:t_list
                                    " Lists can be used for buffer-local variables only
                                    let l:callback_list = b:ale_fixers
                                else
                                    " buffer and global options can use dictionaries mapping filetypes to
                                    " callbacks to run.
                                    let l:fixers = ale#Var(a:buffer, 'fixers')
                                    let l:callback_list = []
                                    let l:matched = 0
                            
                                    for l:sub_type in split(&filetype, '\.')
                                        if s:AddSubCallbacks(l:callback_list, get(l:fixers, l:sub_type))
                                            let l:matched = 1
                                        endif
                                    endfor
                            
                                    " If we couldn't find fixers for a filetype, default to '*' fixers.
                                    if !l:matched
                                        call s:AddSubCallbacks(l:callback_list, get(l:fixers, '*'))
                                    endif
                                endif
                            
                                if a:fixing_flag is# 'save_file'
                                    let l:config = ale#Var(a:buffer, 'fix_on_save_ignore')
                            
                                    if !empty(l:config)
                                        call s:IgnoreFixers(l:callback_list, &filetype, l:config)
                                    endif
                                endif
                            
                                let l:corrected_list = []
                            
                                " Variables with capital characters are needed, or Vim will complain about
                                " funcref variables.
                                for l:Item in l:callback_list
                                    " Try to capture the names of registered fixer names, so we can use
                                    " them for filename mapping or other purposes later.
                                    let l:fixer_name = v:null
                            
                                    if type(l:Item) is v:t_string
                                        let l:Func = ale#fix#registry#GetFunc(l:Item)
                            
                                        if !empty(l:Func)
                                            let l:fixer_name = l:Item
                                            let l:Item = l:Func
                                        endif
                                    endif
                            
                                    try
                                        call add(l:corrected_list, [
                                        \   l:fixer_name,
                                        \   ale#util#GetFunction(l:Item)
                                        \])
                                    catch /E475/
                                        " Rethrow exceptions for failing to get a function so we can print
                                        " a friendly message about it.
                                        throw 'BADNAME ' . v:exception
                                    endtry
                                endfor
                            
                                return l:corrected_list
                            endfunction
                            
    1              0.000001 function! ale#fix#InitBufferData(buffer, fixing_flag) abort
                                " The 'done' flag tells the function for applying changes when fixing
                                " is complete.
                                let g:ale_fix_buffer_data[a:buffer] = {
                                \   'lines_before': getbufline(a:buffer, 1, '$'),
                                \   'done': 0,
                                \   'should_save': a:fixing_flag is# 'save_file',
                                \   'ignore_file_changed_errors': a:fixing_flag is# '!',
                                \   'temporary_directory_list': [],
                                \}
                            endfunction
                            
                            " Accepts an optional argument for what to do when fixing.
                            "
                            " Returns 0 if no fixes can be applied, and 1 if fixing can be done.
    1              0.000002 function! ale#fix#Fix(buffer, fixing_flag, ...) abort
                                if a:fixing_flag isnot# ''
                                \&& a:fixing_flag isnot# '!'
                                \&& a:fixing_flag isnot# 'save_file'
                                    throw "fixing_flag must be '', '!', or 'save_file'"
                                endif
                            
                                try
                                    let l:callback_list = s:GetCallbacks(a:buffer, a:fixing_flag, a:000)
                                catch /E700\|BADNAME/
                                    if a:fixing_flag isnot# '!'
                                        let l:function_name = join(split(split(v:exception, ':')[3]))
                                        let l:echo_message = printf(
                                        \   'There is no fixer named `%s`. Check :ALEFixSuggest',
                                        \   l:function_name,
                                        \)
                                        execute 'echom l:echo_message'
                                    endif
                            
                                    return 0
                                endtry
                            
                                if empty(l:callback_list)
                                    if a:fixing_flag is# ''
                                        execute 'echom ''No fixers have been defined. Try :ALEFixSuggest'''
                                    endif
                            
                                    return 0
                                endif
                            
                                call ale#command#StopJobs(a:buffer, 'fixer')
                                " Clean up any files we might have left behind from a previous run.
                                call ale#command#RemoveManagedFiles(a:buffer)
                                call ale#fix#InitBufferData(a:buffer, a:fixing_flag)
                            
                                silent doautocmd <nomodeline> User ALEFixPre
                            
                                call s:RunFixer({
                                \   'buffer': a:buffer,
                                \   'input': g:ale_fix_buffer_data[a:buffer].lines_before,
                                \   'callback_index': 0,
                                \   'callback_list': l:callback_list,
                                \})
                            
                                return 1
                            endfunction
                            
                            " Set up an autocmd command to try and apply buffer fixes when available.
    1              0.000002 augroup ALEBufferFixGroup
    1              0.000160     autocmd!
    1              0.000010     autocmd BufEnter * call ale#fix#ApplyQueuedFixes(str2nr(expand('<abuf>')))
    1              0.000003 augroup END

FUNCTION  GetJavascriptGraphQLIndent()
    Defined: ~/.config/nvim/plugged/vim-polyglot/after/indent/javascript-2.vim line 39
Called 1 time
Total time:   0.010450
 Self time:   0.000689

count  total (s)   self (s)
    1              0.000670   let l:stack = map(synstack(v:lnum, 1), "synIDattr(v:val, 'name')")
    1              0.000004   if get(l:stack, 0, '') ==# 'graphqlTemplateString'
                                return GetGraphQLIndent()
    1              0.000001   endif
                            
    1   0.009772   0.000010   return eval(b:indentexpr_base)

FUNCTION  <SNR>71_GetPair()
    Defined: ~/.config/nvim/plugged/vim-polyglot/indent/javascript.vim line 75
Called 5 times
Total time:   0.008045
 Self time:   0.000157

count  total (s)   self (s)
    5   0.008044   0.000155     return searchpair('\m'.a:start,'','\m'.a:end,a:flags,a:skip,s:l1,a:skip ==# 's:SkipFunc()' ? 2000 : 200)

FUNCTION  coc#client#get_channel()
    Defined: ~/.config/nvim/plugged/coc.nvim/autoload/coc/client.vim line 146
Called 117 times
Total time:   0.000639
 Self time:   0.000639

count  total (s)   self (s)
  117              0.000161   if s:is_vim
                                return a:client['channel']
  117              0.000050   endif
  117              0.000173   return a:client['chan_id']

FUNCTION  2()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/autoloclist.vim line 15
Called 3 times
Total time:   0.000286
 Self time:   0.000027

count  total (s)   self (s)
    3   0.000036   0.000014     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: refresh')
    3   0.000249   0.000011     call g:SyntasticAutoloclistNotifier.AutoToggle(a:loclist)

FUNCTION  3()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/autoloclist.vim line 20
Called 3 times
Total time:   0.000237
 Self time:   0.000141

count  total (s)   self (s)
    3   0.000032   0.000012     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: toggle')
    3   0.000037   0.000012     let auto_loc_list = syntastic#util#var('auto_loc_list')
    3   0.000012   0.000008     if !a:loclist.isEmpty()
                                    if auto_loc_list == 1 || auto_loc_list == 3
                                        call a:loclist.show()
                                    endif
    3              0.000001     else
    3              0.000014         if (auto_loc_list == 1 || auto_loc_list == 2) && !empty(get(w:, 'syntastic_loclist_set', []))
    3              0.000002             try
                                            " Vim 7.4.2200 or later
    3              0.000015                 let title = get(getloclist(0, { 'title': 1 }), 'title', ':SyntasticCheck ')
                                        catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                            let title = ':SyntasticCheck '
    3              0.000002             endtry
                            
    3              0.000006             if strpart(title, 0, 16) ==# ':SyntasticCheck '
                                            " TODO: this will close the loc list window if one was opened
                                            " by something other than syntastic
    3   0.000059   0.000012                 call SyntasticLoclistHide()
                            
    3              0.000002                 try
                                                " Vim 7.4.2200 or later
    3              0.000009                     call setloclist(0, [], 'r', { 'title': '' })
                                            catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                                " do nothing
    3              0.000001                 endtry
    3              0.000004                 let w:syntastic_loclist_set = []
    3              0.000001             endif
    3              0.000001         endif
    3              0.000001     endif

FUNCTION  5()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/balloons.vim line 19
Called 3 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    3              0.000010     return has('balloon_eval') && syntastic#util#var('enable_balloons')

FUNCTION  7()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/balloons.vim line 36
Called 3 times
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
    3              0.000018     if has('balloon_eval') && !empty(get(b:, 'syntastic_private_balloons', {}))
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'balloons: reset')
                                    set noballooneval
    3              0.000001     endif
    3              0.000005     unlet! b:syntastic_private_balloons

FUNCTION  9()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/checker.vim line 60
Called 6 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    6              0.000017     return self._filetype

FUNCTION  <SNR>217_FilterResult()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/handlers/eslint.vim line 222
Called 21 times
Total time:   0.000279
 Self time:   0.000169

count  total (s)   self (s)
   21   0.000169   0.000059     if ale#Var(a:buffer, 'javascript_eslint_suppress_eslintignore')
                                    if a:obj.text =~# '^File ignored'
                                        return 0
                                    endif
   21              0.000005     endif
                            
   21              0.000042     if has_key(a:obj, 'code') && a:obj.code is# 'no-trailing-spaces'&& !ale#Var(a:buffer, 'warn_about_trailing_whitespace')
                                    return 0
   21              0.000005     endif
                            
   21              0.000008     return 1

FUNCTION  <SNR>40_CacheErrors()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic.vim line 454
Called 3 times
Total time:   0.022128
 Self time:   0.000833

count  total (s)   self (s)
    3   0.000050   0.000024     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
    3   0.000758   0.000045     call s:ClearCache(a:buf)
    3   0.000084   0.000019     let newLoclist = g:SyntasticLoclist.New([])
    3   0.000020   0.000010     call newLoclist.setOwner(a:buf)
                            
    3   0.017209   0.000016     if !s:_skip_file(a:buf)
                                    " debug logging {{{3
    3   0.000099   0.000057         call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'aggregate_errors')
    3   0.000053   0.000021         if syntastic#util#isRunningWindows()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMP = ' . string($TMP) . ', $TEMP = ' . string($TEMP))
    3              0.000003         else
    3   0.000071   0.000039             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TERM = ' . string($TERM))
    3   0.000059   0.000030             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMPDIR = ' . string($TMPDIR))
    3              0.000001         endif
    3   0.000058   0.000031         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$PATH = ' . string($PATH))
    3   0.000056   0.000029         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getcwd() = ' . string(getcwd()))
                                    " }}}3
                            
    3   0.000820   0.000038         let clist = s:registry.getCheckers(getbufvar(a:buf, '&filetype'), a:checker_names)
                            
    3   0.000277   0.000077         let aggregate_errors = syntastic#util#var('aggregate_errors') || len(syntastic#util#unique(map(copy(clist), 'v:val.getFiletype()'))) > 1
    3              0.000008         let decorate_errors = aggregate_errors && syntastic#util#var('id_checkers')
    3              0.000007         let sort_aggregated_errors = aggregate_errors && syntastic#util#var('sort_aggregated_errors')
                            
    3              0.000004         let names = []
    3              0.000014         let unavailable_checkers = 0
    9              0.000010         for checker in clist
    6   0.000045   0.000029             let cname = checker.getCName()
    6   0.001834   0.000022             if !checker.isAvailable()
    6   0.000108   0.000059                 call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Checker ' . cname . ' is not available')
    6              0.000010                 let unavailable_checkers += 1
    6              0.000005                 continue
                                        endif
                            
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Invoking checker: ' . cname)
                            
                                        let loclist = checker.getLocList()
                            
                                        if !loclist.isEmpty()
                                            if decorate_errors
                                                call loclist.decorate(cname)
                                            endif
                                            call add(names, cname)
                                            if checker.wantSort() && !sort_aggregated_errors
                                                call loclist.sort()
                                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', loclist)
                                            endif
                            
                                            call newLoclist.extend(loclist)
                            
                                            if !aggregate_errors
                                                break
                                            endif
                                        endif
    3              0.000003         endfor
                            
                                    " set names {{{3
    3              0.000004         if !empty(names)
                                        if len(syntastic#util#unique(map( copy(names), 'substitute(v:val, "\\m/.*", "", "")' ))) == 1
                                            let type = substitute(names[0], '\m/.*', '', '')
                                            let name = join(map( names, 'substitute(v:val, "\\m.\\{-}/", "", "")' ), ', ')
                                            call newLoclist.setName( name . ' ('. type . ')' )
                                        else
                                            " checkers from mixed types
                                            call newLoclist.setName(join(names, ', '))
                                        endif
    3              0.000001         endif
                                    " }}}3
                            
                                    " issue warning about no active checkers {{{3
    3              0.000005         if len(clist) == unavailable_checkers
    3              0.000004             if !empty(a:checker_names)
                                            if len(a:checker_names) == 1
                                                call syntastic#log#warn('checker ' . a:checker_names[0] . ' is not available')
                                            else
                                                call syntastic#log#warn('checkers ' . join(a:checker_names, ', ') . ' are not available')
                                            endif
    3              0.000001             else
    3   0.000041   0.000020                 call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: no checkers available for ' . &filetype)
    3              0.000001             endif
    3              0.000001         endif
                                    " }}}3
                            
    3   0.000034   0.000015         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'aggregated:', newLoclist)
    3              0.000003         if sort_aggregated_errors
                                        call newLoclist.sort()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', newLoclist)
    3              0.000001         endif
    3              0.000001     endif
                            
    3   0.000210   0.000009     call newLoclist.deploy()

FUNCTION  <SNR>261_highlight_range()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/highlight.vim line 122
Called 21 times
Total time:   0.001385
 Self time:   0.000250

count  total (s)   self (s)
                                " Set all of the positions, which are chunked into Lists which
                                " are as large as will be accepted by matchaddpos.
   21   0.001369   0.000235     call map(   ale#highlight#CreatePositions(       a:range.lnum,       a:range.col,       a:range.end_lnum,       a:range.end_col   ),   's:matchaddpos(a:group, v:val)')

FUNCTION  ale#linter#Get()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/linter.vim line 367
Called 20 times
Total time:   0.008570
 Self time:   0.005726

count  total (s)   self (s)
   20              0.000042     let l:possibly_duplicated_linters = []
                            
                                " Handle dot-separated filetypes.
   40              0.000218     for l:original_filetype in split(a:original_filetypes, '\.')
   20   0.001191   0.000173         let l:filetype = ale#linter#ResolveFiletype(l:original_filetype)
   20   0.000776   0.000196         let l:linter_names = s:GetLinterNames(l:original_filetype)
   20   0.001410   0.000162         let l:all_linters = ale#linter#GetAll(l:filetype)
   20              0.000028         let l:filetype_linters = []
                            
   20              0.000063         if type(l:linter_names) is v:t_string && l:linter_names is# 'all'
                                        let l:filetype_linters = l:all_linters
   20              0.000036         elseif type(l:linter_names) is v:t_list
                                        " Select only the linters we or the user has specified.
  220              0.000210             for l:linter in l:all_linters
  200              0.000613                 let l:name_list = [l:linter.name] + l:linter.aliases
                            
  360              0.000359                 for l:name in l:name_list
  200              0.000501                     if index(l:linter_names, l:name) >= 0
   40              0.000091                         call add(l:filetype_linters, l:linter)
   40              0.000029                         break
  160              0.000095                     endif
  360              0.000207                 endfor
  220              0.000098             endfor
   20              0.000026         endif
                            
   20              0.000056         call extend(l:possibly_duplicated_linters, l:filetype_linters)
   40              0.000034     endfor
                            
   20              0.000030     let l:name_list = []
   20              0.000029     let l:combined_linters = []
                            
                                " Make sure we override linters so we don't get two with the same name,
                                " like 'eslint' for both 'javascript' and 'typescript'
                                "
                                " Note that the reverse calls here modify the List variables.
   60              0.000083     for l:linter in reverse(l:possibly_duplicated_linters)
   40              0.000081         if index(l:name_list, l:linter.name) < 0
   40              0.000077             call add(l:name_list, l:linter.name)
   40              0.000066             call add(l:combined_linters, l:linter)
   40              0.000017         endif
   60              0.000029     endfor
                            
   20              0.000044     return reverse(l:combined_linters)

FUNCTION  <SNR>253_is_jsx_backticks()
    Defined: ~/.config/nvim/plugged/vim-polyglot/autoload/jsx_pretty/indent.vim line 96
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000003   return a:syntax =~? 'jsxBackticks'

FUNCTION  syntastic#log#debugShowOptions()
    Defined: ~/.config/nvim/plugged/syntastic/autoload/syntastic/log.vim line 83
Called 4 times
Total time:   0.000032
 Self time:   0.000025

count  total (s)   self (s)
    4   0.000028   0.000022     if !s:_isDebugEnabled(a:level)
    4              0.000002         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = copy(type(a:names) == type('') ? [a:names] : a:names)
                                let add_shell = index(vlist, 'shell') >= 0 && &shell !=# syntastic#util#var('shell')
                                if !empty(vlist)
                                    call map(vlist, "'&' . v:val . ' = ' . strtrans(string(eval('&' . v:val))) . (s:_is_modified(v:val) ? ' (!)' : '')")
                                    if add_shell
                                        call add(vlist, 'u:shell = ' . strtrans(string(syntastic#util#var('shell'))) . ' (!)')
                                    endif
                                    echomsg leader . join(vlist, ', ')
                                endif
                                call s:_logRedirect(0)

FUNCTION  <SNR>217_HandleESLintOutput()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/handlers/eslint.vim line 237
Called 1 time
Total time:   0.001522
 Self time:   0.000106

count  total (s)   self (s)
    1   0.000507   0.000007     if s:CheckForBadConfig(a:buffer, a:lines)
                                    return [{   'lnum': 1,   'text': 'eslint configuration error (type :ALEDetail for more information)',   'detail': join(a:lines, "\n"),}]
    1              0.000000     endif
                            
    1              0.000002     if a:lines == ['Could not connect']
                                    return [{   'lnum': 1,   'text': 'Could not connect to eslint_d. Try updating eslint_d or killing it.',}]
    1              0.000000     endif
                            
    1              0.000001     if a:type is# 'json'
    1   0.000580   0.000023         let l:output = s:parseJSON(a:buffer, a:lines)
                                else
                                    let l:output = s:parseLines(a:buffer, a:lines)
    1              0.000000     endif
                            
    1   0.000411   0.000054     call filter(l:output, {idx, obj -> s:FilterResult(a:buffer, obj)})
                            
    1              0.000007     if expand('#' . a:buffer . ':t') =~? '\.tsx\?$'
                                    call s:AddHintsForTypeScriptParsingErrors(l:output)
    1              0.000000     endif
                            
    1              0.000001     return l:output

FUNCTION  GetJsxIndent()
    Defined: ~/.config/nvim/plugged/vim-polyglot/after/indent/jsx.vim line 28
Called 1 time
Total time:   0.009761
 Self time:   0.000010

count  total (s)   self (s)
    1   0.009761   0.000010   return jsx_pretty#indent#get(function('GetJavascriptIndent'))

FUNCTION  ale#handlers#eslint#HandleJSON()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/handlers/eslint.vim line 268
Called 1 time
Total time:   0.001528
 Self time:   0.000007

count  total (s)   self (s)
    1   0.001528   0.000007     return s:HandleESLintOutput(a:buffer, a:lines, 'json')

FUNCTION  <SNR>71_Token()
    Defined: ~/.config/nvim/plugged/vim-polyglot/indent/javascript.vim line 169
Called 2 times
Total time:   0.000027
 Self time:   0.000019

count  total (s)   self (s)
    2   0.000026   0.000018   return s:LookingAt() =~ '\k' ? expand('<cword>') : s:LookingAt()

FUNCTION  ale#events#QuitRecently()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/events.vim line 19
Called 8 times
Total time:   0.000070
 Self time:   0.000063

count  total (s)   self (s)
    8              0.000028     let l:time = getbufvar(a:buffer, 'ale_quitting', 0)
                            
    8   0.000035   0.000028     return l:time && ale#events#ClockMilliseconds() - l:time < 1000

FUNCTION  <SNR>49_Highlight_Matching_Pair()
    Defined: /usr/share/nvim/runtime/plugin/matchparen.vim line 39
Called 40 times
Total time:   0.030223
 Self time:   0.030223

count  total (s)   self (s)
                              " Remove any previous match.
   40              0.000175   if exists('w:paren_hl_on') && w:paren_hl_on
    2              0.000005     silent! call matchdelete(3)
    2              0.000002     let w:paren_hl_on = 0
   40              0.000034   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   40              0.000176   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
   40              0.000018   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   40              0.000098   let c_lnum = line('.')
   40              0.000086   let c_col = col('.')
   40              0.000057   let before = 0
                            
   40              0.000109   let text = getline(c_lnum)
   40              0.000732   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
   40              0.000085   if empty(matches)
                                let [c_before, c] = ['', '']
   40              0.000028   else
   40              0.000185     let [c_before, c] = matches[1:2]
   40              0.000024   endif
   40              0.000657   let plist = split(&matchpairs, '.\zs[:,]')
   40              0.000173   let i = index(plist, c)
   40              0.000072   if i < 0
                                " not found, in Insert mode try character before the cursor
   38              0.000188     if c_col > 1 && (mode() == 'i' || mode() == 'R')
   13              0.000024       let before = strlen(c_before)
   13              0.000012       let c = c_before
   13              0.000020       let i = index(plist, c)
   38              0.000024     endif
   38              0.000039     if i < 0
                                  " not found, nothing to do
   38              0.000037       return
                                endif
    2              0.000001   endif
                            
                              " Figure out the arguments for searchpairpos().
    2              0.000002   if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
    2              0.000001   else
    2              0.000002     let s_flags = 'nbW'
    2              0.000002     let c2 = c
    2              0.000003     let c = plist[i - 1]
    2              0.000001   endif
    2              0.000001   if c == '['
                                let c = '\['
                                let c2 = '\]'
    2              0.000001   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
    2              0.000001   if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
    2              0.000001   endif
                            
    2              0.000012   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
    2              0.000001   else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
    2              0.000005     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
    2              0.000001     try
    2              0.001077       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
    2              0.000001     endtry
    2              0.000001   endif
                            
                              " Limit the search to lines visible in the window.
    2              0.000016   let stoplinebottom = line('w$')
    2              0.000003   let stoplinetop = line('w0')
    2              0.000002   if i % 2 == 0
                                let stopline = stoplinebottom
    2              0.000001   else
    2              0.000003     let stopline = stoplinetop
    2              0.000001   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
    2              0.000004   if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
    2              0.000001   else
    2              0.000006     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
    2              0.000001   endif
    2              0.000001   try
    2              0.024972     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
    2              0.000002   endtry
                            
    2              0.000002   if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
    2              0.000001   endif
                            
                              " If a match is found setup match highlighting.
    2              0.000004   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
    2              0.000005     if exists('*matchaddpos')
    2              0.000111       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
    2              0.000001     endif
    2              0.000003     let w:paren_hl_on = 1
    2              0.000001   endif

FUNCTION  <SNR>253_is_opening_tag()
    Defined: ~/.config/nvim/plugged/vim-polyglot/autoload/jsx_pretty/indent.vim line 56
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002   return a:syntax =~? 'jsxOpenPunct'

FUNCTION  ale#highlight#RemoveHighlights()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/highlight.vim line 72
Called 1 time
Total time:   0.000025
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000001     if s:has_nvim_highlight
    1   0.000018   0.000008         call ale#highlight#nvim_buf_clear_namespace(bufnr(''), s:ns_id, 0, -1)
                                else
                                    for l:match in getmatches()
                                        if l:match.group =~? '\v^ALE(Style)?(Error|Warning|Info)(Line)?$'
                                            call matchdelete(l:match.id)
                                        endif
                                    endfor
    1              0.000000     endif

FUNCTION  <SNR>71_LookingAt()
    Defined: ~/.config/nvim/plugged/vim-polyglot/indent/javascript.vim line 165
Called 12 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
   12              0.000024   return getline('.')[col('.')-1]

FUNCTION  ale#sign#FindCurrentSigns()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/sign.vim line 231
Called 1 time
Total time:   0.000759
 Self time:   0.000013

count  total (s)   self (s)
    1   0.000077   0.000006     let l:line_list = ale#sign#ReadSigns(a:buffer)
                            
    1   0.000682   0.000007     return ale#sign#ParseSigns(l:line_list)

FUNCTION  <SNR>260_ShouldOpen()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/list.vim line 40
Called 2 times
Total time:   0.000028
 Self time:   0.000015

count  total (s)   self (s)
    2   0.000020   0.000008     let l:val = ale#Var(a:buffer, 'open_list')
    2              0.000003     let l:saved = getbufvar(a:buffer, 'ale_save_event_fired', 0)
                            
    2              0.000003     return l:val is 1 || (l:val is# 'on_save' && l:saved)

FUNCTION  ale#highlight#nvim_buf_add_highlight()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/highlight.vim line 36
Called 22 times
Total time:   0.000387
 Self time:   0.000387

count  total (s)   self (s)
                                " Ignore all errors for adding highlights.
   22              0.000009     try
   22              0.000331         call nvim_buf_add_highlight(a:buffer, a:ns_id, a:hl_group, a:line, a:col_start, a:col_end)
                                catch
   22              0.000010     endtry

FUNCTION  ale#node#FindNearestExecutable()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/node.vim line 26
Called 80 times
Total time:   2.858749
 Self time:   0.002882

count  total (s)   self (s)
  160              0.000338     for l:path in a:path_list
  140   2.857452   0.001585         let l:executable = ale#path#FindNearestFile(a:buffer, l:path)
                            
  140              0.000382         if !empty(l:executable)
   60              0.000079             return l:executable
   80              0.000031         endif
  100              0.000081     endfor
                            
   20              0.000015     return ''

FUNCTION  syntastic#log#debug()
    Defined: ~/.config/nvim/plugged/syntastic/autoload/syntastic/log.vim line 63
Called 67 times
Total time:   0.000556
 Self time:   0.000428

count  total (s)   self (s)
   67   0.000493   0.000366     if !s:_isDebugEnabled(a:level)
   67              0.000032         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                if a:0
                                    " filter out dictionary functions
                                    echomsg leader . a:msg . ' ' . strtrans(string(type(a:1) == type({}) || type(a:1) == type([]) ? filter(copy(a:1), 'type(v:val) != type(function("tr"))') : a:1))
                                else
                                    echomsg leader . a:msg
                                endif
                            
                                call s:_logRedirect(0)

FUNCTION  <SNR>212_FormatFilename()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/command.vim line 156
Called 20 times
Total time:   0.000557
 Self time:   0.000319

count  total (s)   self (s)
   20              0.000039     let l:filename = a:filename
                            
   20              0.000034     if !empty(a:mappings)
                                    let l:filename = ale#filename_mapping#Map(l:filename, a:mappings)
   20              0.000012     endif
                            
   20              0.000027     if !empty(a:modifiers)
                                    let l:filename = fnamemodify(l:filename, a:modifiers)
   20              0.000006     endif
                            
   20   0.000335   0.000097     return ale#Escape(l:filename)

FUNCTION  coc#float#check_related()
    Defined: ~/.config/nvim/plugged/coc.nvim/autoload/coc/float.vim line 800
Called 14 times
Total time:   0.000927
 Self time:   0.000927

count  total (s)   self (s)
   14              0.000098   let invalids = []
   14              0.000047   if s:is_vim
                                if !exists('*popup_list')
                                  return
                                endif
                                for id in popup_list()
                                  let target = getwinvar(id, 'target_winid', 0)
                                  if (target && !s:popup_visible(target)) || getwinvar(id, 'kind', '') == 'pum'
                                    call add(invalids, id)
                                  endif
                                endfor
   14              0.000011   else
   28              0.000093     for i in range(1, winnr('$'))
   14              0.000052       let target = getwinvar(i, 'target_winid', 0)
   14              0.000026       if target && !nvim_win_is_valid(target)
                                    call add(invalids, win_getid(i))
   14              0.000046       elseif getwinvar(i, 'kind', '') == 'pum'
                                    call add(invalids, win_getid(i))
   14              0.000006       endif
   28              0.000022     endfor
   14              0.000008   endif
   14              0.000019   for id in invalids
                                call coc#float#close(id)
   14              0.000008   endfor

FUNCTION  ale#GetFilenameMappings()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale.vim line 269
Called 21 times
Total time:   0.000502
 Self time:   0.000325

count  total (s)   self (s)
   21   0.000276   0.000100     let l:linter_mappings = ale#Var(a:buffer, 'filename_mappings')
                            
   21              0.000037     if type(l:linter_mappings) is v:t_list
                                    return l:linter_mappings
   21              0.000007     endif
                            
   21              0.000019     let l:name = a:name
                            
   21              0.000034     if !has_key(l:linter_mappings, l:name)
                                    " Use * as a default setting for all tools.
   21              0.000017         let l:name = '*'
   21              0.000007     endif
                            
   21              0.000038     return get(l:linter_mappings, l:name, [])

FUNCTION  ale#fix#Fix()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/fix.vim line 345
Called 3 times
Total time:   0.000655
 Self time:   0.000140

count  total (s)   self (s)
    3              0.000013     if a:fixing_flag isnot# ''&& a:fixing_flag isnot# '!'&& a:fixing_flag isnot# 'save_file'
                                    throw "fixing_flag must be '', '!', or 'save_file'"
    3              0.000002     endif
                            
    3              0.000002     try
    3   0.000573   0.000058         let l:callback_list = s:GetCallbacks(a:buffer, a:fixing_flag, a:000)
                                catch /E700\|BADNAME/
                                    if a:fixing_flag isnot# '!'
                                        let l:function_name = join(split(split(v:exception, ':')[3]))
                                        let l:echo_message = printf(   'There is no fixer named `%s`. Check :ALEFixSuggest',   l:function_name,)
                                        execute 'echom l:echo_message'
                                    endif
                            
                                    return 0
    3              0.000002     endtry
                            
    3              0.000006     if empty(l:callback_list)
    3              0.000004         if a:fixing_flag is# ''
                                        execute 'echom ''No fixers have been defined. Try :ALEFixSuggest'''
    3              0.000001         endif
                            
    3              0.000002         return 0
                                endif
                            
                                call ale#command#StopJobs(a:buffer, 'fixer')
                                " Clean up any files we might have left behind from a previous run.
                                call ale#command#RemoveManagedFiles(a:buffer)
                                call ale#fix#InitBufferData(a:buffer, a:fixing_flag)
                            
                                silent doautocmd <nomodeline> User ALEFixPre
                            
                                call s:RunFixer({   'buffer': a:buffer,   'input': g:ale_fix_buffer_data[a:buffer].lines_before,   'callback_index': 0,   'callback_list': l:callback_list,})
                            
                                return 1

FUNCTION  jsx_pretty#indent#get()
    Defined: ~/.config/nvim/plugged/vim-polyglot/autoload/jsx_pretty/indent.vim line 240
Called 1 time
Total time:   0.009751
 Self time:   0.000090

count  total (s)   self (s)
    1   0.000021   0.000009   let line = s:trim(getline(v:lnum))
    1   0.000029   0.000008   let start_syntax = s:start_syntax(v:lnum)
                            
    1   0.000009   0.000006   if s:is_jsx_backticks(start_syntax)
                                return s:jsx_indent_backticks(v:lnum)
    1              0.000000   endif
                            
    1   0.000007   0.000004   if s:is_jsx_brace(start_syntax)
                                return s:jsx_indent_element(v:lnum)
    1              0.000000   endif
                            
    1   0.000008   0.000005   if s:is_opening_tag(start_syntax) && line =~ '^>'
                                return s:jsx_indent_trail_punct(v:lnum)
    1              0.000000   endif
                            
    1   0.000654   0.000006   let syntax_context = s:syntax_context(v:lnum)
                            
    1              0.000001   if syntax_context == 'jsxRegion'
                                if s:is_closing_tag(start_syntax)
                                  return s:jsx_indent_closing_tag(v:lnum)
                                endif
                            
                                let prev_lnum = s:prev_lnum(v:lnum)
                                let prev_line = s:trim(getline(prev_lnum))
                            
                                if prev_line =~ '[([{=?]$'
                                  return indent(prev_lnum) + s:sw()
                                elseif prev_line =~ '[:|&<>]$' && s:trim(getline(s:prev_lnum(prev_lnum))) !~ '[?:|&<>]$'
                                  return indent(prev_lnum) + s:sw()
                                else
                                  return indent(prev_lnum)
                                endif
    1              0.000001   elseif syntax_context == 'jsxTaggedRegion'
                                if s:is_closing_tag(start_syntax)
                                  return s:jsx_indent_closing_tag(v:lnum)
                                elseif s:is_jsx_comment(start_syntax)
                                  return s:jsx_indent_comment(v:lnum)
                                else
                                  return indent(s:prev_lnum(v:lnum)) + s:sw()
                                endif
    1              0.000001   elseif syntax_context == 'jsxElement'
                                if s:is_jsx_comment(start_syntax)
                                  return s:jsx_indent_comment(v:lnum)
                                endif
                            
                                if s:is_comment(start_syntax)
                                  return s:jsx_indent_comment(v:lnum)
                                endif
                            
                                return s:jsx_indent_element(v:lnum)
    1              0.000001   elseif syntax_context == 'jsxExpressionBlock'
                                let prev_lnum = s:prev_lnum(v:lnum)
                                let prev_line = s:trim(getline(prev_lnum))
                            
                                if line =~ '^?'
                                  return indent(prev_lnum) + s:sw()
                                elseif line =~ '^:'
                                  return indent(prev_lnum)
                                else
                                  return a:js_indent()
                                endif
    1              0.000000   endif
                            
    1   0.008977   0.000006   return a:js_indent()

FUNCTION  ale#FileTooLarge()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale.vim line 24
Called 55 times
Total time:   0.000536
 Self time:   0.000536

count  total (s)   self (s)
   55              0.000278     let l:max = getbufvar(a:buffer, 'ale_maximum_file_size', get(g:, 'ale_maximum_file_size', 0))
                            
   55              0.000194     return l:max > 0 ? (line2byte(line('$') + 1) > l:max) : 0

FUNCTION  coc#util#cursor()
    Defined: ~/.config/nvim/plugged/coc.nvim/autoload/coc/util.vim line 35
Called 16 times
Total time:   0.000341
 Self time:   0.000341

count  total (s)   self (s)
   16              0.000306   return [line('.') - 1, strchars(strpart(getline('.'), 0, col('.') - 1))]

FUNCTION  ale#highlight#UpdateHighlights()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/highlight.vim line 136
Called 1 time
Total time:   0.001847
 Self time:   0.000437

count  total (s)   self (s)
    1              0.000003     let l:item_list = get(b:, 'ale_enabled', 1) && g:ale_enabled   ? get(b:, 'ale_highlight_items', [])   : []
                            
    1   0.000030   0.000004     call ale#highlight#RemoveHighlights()
                            
   22              0.000015     for l:item in l:item_list
   21              0.000019         if l:item.type is# 'W'
   21              0.000030             if get(l:item, 'sub_type', '') is# 'style'
                                            let l:group = 'ALEStyleWarning'
   21              0.000006             else
   21              0.000017                 let l:group = 'ALEWarning'
   21              0.000006             endif
                                    elseif l:item.type is# 'I'
                                        let l:group = 'ALEInfo'
                                    elseif get(l:item, 'sub_type', '') is# 'style'
                                        let l:group = 'ALEStyleError'
                                    else
                                        let l:group = 'ALEError'
   21              0.000005         endif
                            
   21              0.000094         let l:range = {   'lnum': l:item.lnum,   'col': l:item.col,   'end_lnum': get(l:item, 'end_lnum', l:item.lnum),   'end_col': get(l:item, 'end_col', l:item.col)}
                            
   21   0.001499   0.000114         call s:highlight_range(l:item.bufnr, l:range, l:group)
   22              0.000009     endfor
                            
                                " If highlights are enabled and signs are not enabled, we should still
                                " offer line highlights by adding a separate set of highlights.
    1              0.000001     if !g:ale_set_signs
                                    let l:available_groups = {   'ALEWarningLine': hlexists('ALEWarningLine'),   'ALEInfoLine': hlexists('ALEInfoLine'),   'ALEErrorLine': hlexists('ALEErrorLine'),}
                            
                                    for l:item in l:item_list
                                        if l:item.type is# 'W'
                                            let l:group = 'ALEWarningLine'
                                        elseif l:item.type is# 'I'
                                            let l:group = 'ALEInfoLine'
                                        else
                                            let l:group = 'ALEErrorLine'
                                        endif
                            
                                        if l:available_groups[l:group]
                                            call s:highlight_line(l:item.bufnr, l:item.lnum, l:group)
                                        endif
                                    endfor
    1              0.000000     endif

FUNCTION  ale#job#Start()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/job.vim line 215
Called 20 times
Total time:   0.012353
 Self time:   0.012272

count  total (s)   self (s)
   20   0.000194   0.000114     call ale#job#ValidateArguments(a:command, a:options)
                            
   20              0.000053     let l:job_info = copy(a:options)
   20              0.000022     let l:job_options = {}
                            
   20              0.000038     if has('nvim')
   20              0.000028         if has_key(a:options, 'out_cb')
   20              0.000061             let l:job_options.on_stdout = function('s:NeoVimCallback')
   20              0.000022             let l:job_info.out_cb_line = ''
   20              0.000008         endif
                            
   20              0.000024         if has_key(a:options, 'err_cb')
   20              0.000043             let l:job_options.on_stderr = function('s:NeoVimCallback')
   20              0.000018             let l:job_info.err_cb_line = ''
   20              0.000006         endif
                            
   20              0.000024         if has_key(a:options, 'exit_cb')
   20              0.000042             let l:job_options.on_exit = function('s:NeoVimCallback')
   20              0.000006         endif
                            
   20              0.010922         let l:job_info.job = jobstart(a:command, l:job_options)
   20              0.000086         let l:job_id = l:job_info.job
                                else
                                    let l:job_options = {   'in_mode': l:job_info.mode,   'out_mode': l:job_info.mode,   'err_mode': l:job_info.mode,}
                            
                                    if has_key(a:options, 'out_cb')
                                        let l:job_options.out_cb = function('s:VimOutputCallback')
                                    endif
                            
                                    if has_key(a:options, 'err_cb')
                                        let l:job_options.err_cb = function('s:VimErrorCallback')
                                    endif
                            
                                    if has_key(a:options, 'exit_cb')
                                        " Set a close callback to which simply calls job_status()
                                        " when the channel is closed, which can trigger the exit callback
                                        " earlier on.
                                        let l:job_options.close_cb = function('s:VimCloseCallback')
                                        let l:job_options.exit_cb = function('s:VimExitCallback')
                                    endif
                            
                                    " Use non-blocking writes for Vim versions that support the option.
                                    if has('patch-8.1.350')
                                        let l:job_options.noblock = 1
                                    endif
                            
                                    " Vim 8 will read the stdin from the file's buffer.
                                    let l:job_info.job = job_start(a:command, l:job_options)
                                    let l:job_id = ale#job#ParseVim8ProcessID(string(l:job_info.job))
   20              0.000008     endif
                            
   20              0.000024     if l:job_id > 0
                                    " Store the job in the map for later only if we can get the ID.
   20              0.000127         let s:job_map[l:job_id] = l:job_info
   20              0.000007     endif
                            
   20              0.000041     return l:job_id

FUNCTION  ale#command#SetCwd()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/command.vim line 34
Called 21 times
Total time:   0.000333
 Self time:   0.000191

count  total (s)   self (s)
   21   0.000260   0.000118     call ale#command#InitData(a:buffer)
   21              0.000056     let s:buffer_data[a:buffer].cwd = a:cwd

FUNCTION  ale#handlers#eslint#GetCommand()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/handlers/eslint.vim line 65
Called 20 times
Total time:   0.812366
 Self time:   0.000596

count  total (s)   self (s)
   20   0.811069   0.000139     let l:executable = ale#handlers#eslint#GetExecutable(a:buffer)
                            
   20   0.000490   0.000253     let l:options = ale#Var(a:buffer, 'javascript_eslint_options')
                            
   20   0.000778   0.000176     return ale#node#Executable(a:buffer, l:executable)   . (!empty(l:options) ? ' ' . l:options : '')   . ' -f json --stdin --stdin-filename %s'

FUNCTION  ale#lsp_linter#StartLSP()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/lsp_linter.vim line 385
Called 20 times
Total time:   1.121866
 Self time:   0.001256

count  total (s)   self (s)
   20              0.000030     let l:command = ''
   20              0.000019     let l:address = ''
   20   0.379149   0.000245     let l:root = ale#lsp_linter#FindProjectRoot(a:buffer, a:linter)
                            
   20              0.000050     if empty(l:root) && a:linter.lsp isnot# 'tsserver'
                                    " If there's no project root, then we can't check files with LSP,
                                    " unless we are using tsserver, which doesn't use project roots.
                                    return 0
   20              0.000029     endif
                            
   20              0.000113     let l:options = {   'buffer': a:buffer,   'linter': a:linter,   'callback': a:Callback,   'root': l:root,}
                            
   20              0.000040     if a:linter.lsp is# 'socket'
                                    let l:address = ale#linter#GetAddress(a:buffer, a:linter)
                            
                                    return s:StartWithAddress(l:options, l:address)
   20              0.000009     endif
                            
   20   0.406383   0.000300     let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                            
   20   0.335793   0.000169     return s:StartIfExecutable(l:options, l:executable)

FUNCTION  <SNR>261_matchaddpos()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/highlight.vim line 89
Called 21 times
Total time:   0.001046
 Self time:   0.000660

count  total (s)   self (s)
   21              0.000016     if s:has_nvim_highlight
   43              0.000041         for l:pos in a:pos_list
   22              0.000050             let l:line = type(l:pos) == v:t_number   ? l:pos - 1   : l:pos[0] - 1
                            
   22              0.000037             if type(l:pos) == v:t_number || len(l:pos) == 1
                                            let l:col_start = 0
                                            let l:col_end = s:MAX_COL_SIZE
   22              0.000007             else
   22              0.000024                 let l:col_start = l:pos[1] - 1
   22              0.000037                 let l:col_end = l:col_start + get(l:pos, 2, 1)
   22              0.000006             endif
                            
   22   0.000531   0.000144             call ale#highlight#nvim_buf_add_highlight(   bufnr(''),   s:ns_id,   a:group,   l:line,   l:col_start,   l:col_end,)
   43              0.000023         endfor
                                else
                                    call matchaddpos(a:group, a:pos_list)
   21              0.000006     endif

FUNCTION  coc#rpc#request()
    Defined: ~/.config/nvim/plugged/coc.nvim/autoload/coc/rpc.vim line 88
Called 4 times
Total time:   0.007489
 Self time:   0.000058

count  total (s)   self (s)
    4   0.000048   0.000019   if !coc#rpc#ready()
                                return ''
    4              0.000001   endif
    4   0.007434   0.000031   return s:client['request'](a:method, a:args)

FUNCTION  coc#float#get_related()
    Defined: ~/.config/nvim/plugged/coc.nvim/autoload/coc/float.vim line 1211
Called 25 times
Total time:   0.000598
 Self time:   0.000598

count  total (s)   self (s)
   25              0.000285   for winid in getwinvar(a:winid, 'related', [])
                                if getwinvar(winid, 'kind', '') ==# a:kind
                                  return winid
                                endif
   25              0.000036   endfor
   25              0.000054   return 0

FUNCTION  ale#sign#ParsePattern()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/sign.vim line 182
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000001     if s:supports_sign_groups
                                    " Matches output like :
                                    " line=4  id=1  group=ale  name=ALEErrorSign
                                    " =1  id=1000001  =ale  =ALEErrorSign
                                    " =1  =1000001  =ale  =ALEWarningSign
                                    " lnea=12 id=1000001 grupo=ale  nombre=ALEWarningSign
                                    " riga=1 id=1000001  gruppo=ale   nome=ALEWarningSign
                                    " Zeile=235  id=1000001 Gruppe=ale  Name=ALEErrorSign
    1              0.000002         let l:pattern = '\v^.*\=(\d+).*\=(\d+).*\=ale>.*\=(ALE[a-zA-Z]+Sign)'
                                else
                                    " Matches output like :
                                    " line=4  id=1  name=ALEErrorSign
                                    " =1  id=1000001  =ALEErrorSign
                                    " =1  =1000001  =ALEWarningSign
                                    " lnea=12 id=1000001 nombre=ALEWarningSign
                                    " riga=1 id=1000001  nome=ALEWarningSign
                                    " Zeile=235  id=1000001  Name=ALEErrorSign
                                    let l:pattern = '\v^.*\=(\d+).*\=(\d+).*\=(ALE[a-zA-Z]+Sign)'
    1              0.000000     endif
                            
    1              0.000001     return l:pattern

FUNCTION  coc#_hide()
    Defined: ~/.config/nvim/plugged/coc.nvim/autoload/coc.vim line 90
Called 2 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    2              0.000010   if !pumvisible() | return | endif
    1              0.000005   call feedkeys("\<C-e>", 'in')

FUNCTION  <SNR>250_StopCursorTimer()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/cursor.vim line 56
Called 39 times
Total time:   0.000318
 Self time:   0.000318

count  total (s)   self (s)
   39              0.000087     if s:cursor_timer != -1
   24              0.000087         call timer_stop(s:cursor_timer)
   24              0.000046         let s:cursor_timer = -1
   39              0.000021     endif

FUNCTION  <SNR>253_start_col()
    Defined: ~/.config/nvim/plugged/vim-polyglot/autoload/jsx_pretty/indent.vim line 35
Called 2 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    2              0.000012   return len(matchstr(getline(a:lnum), '^\s*')) + 1

FUNCTION  <SNR>20_notify()
    Defined: ~/.config/nvim/plugged/coc.nvim/autoload/coc/client.vim line 186
Called 113 times
Total time:   0.010783
 Self time:   0.010161

count  total (s)   self (s)
  113   0.001612   0.000990   let channel = coc#client#get_channel(self)
  113              0.000175   if empty(channel)
                                return ''
  113              0.000042   endif
  113              0.000115   try
  113              0.000140     if s:is_vim
                                  call ch_sendraw(channel, json_encode([0, [a:method, a:args]])."\n")
  113              0.000133     else
  113              0.004975       call call('rpcnotify', [channel, a:method] + a:args)
  113              0.000187     endif
                              catch /.*/
                                if v:exception =~# 'E475'
                                  if get(g:, 'coc_vim_leaving', 0)
                                    return
                                  endif
                                  echohl Error | echom '['.self.name.'] server connection lost' | echohl None
                                  let name = self.name
                                  call s:on_exit(name, 0)
                                  execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
                                elseif v:exception =~# 'E12'
                                  " neovim's bug, ignore it
                                else
                                  echohl Error | echo 'Error on notify ('.a:method.'): '.v:exception | echohl None
                                endif
  113              0.000128   endtry

FUNCTION  <SNR>253_syntax_context()
    Defined: ~/.config/nvim/plugged/vim-polyglot/autoload/jsx_pretty/indent.vim line 198
Called 1 time
Total time:   0.000648
 Self time:   0.000143

count  total (s)   self (s)
    1   0.000011   0.000005   let start_col = s:start_col(a:lnum)
    1   0.000475   0.000006   let syntax_stack = s:syntax_stack_at(a:lnum, start_col)
    1              0.000002   let start_syntax = syntax_stack[-1]
    1              0.000002   let reversed = reverse(syntax_stack)
    1              0.000001   let i = 0
                            
    5              0.000005   for syntax_name in reversed
                                " If the current line is jsxExpressionBlock and not starts with jsxBraces
    4   0.000034   0.000019     if s:is_jsx_expression(syntax_name)
                                  return 'jsxExpressionBlock'
    4              0.000001     endif
                            
    4   0.000026   0.000017     if s:is_jsx_region(syntax_name)
                                  return 'jsxRegion'
    4              0.000001     endif
                            
    4   0.000023   0.000015     if s:is_jsx_element(syntax_name)
                                  " If current line starts with the opening tag
                                  if s:is_opening_tag(start_syntax) || s:is_closing_tag(start_syntax)
                                    " And the next syntax is jsxRegion
                                    if s:is_jsx_region(reversed[i+1])
                                      return 'jsxRegion'
                                    elseif reversed[i+1] =~ 'jsxTaggedRegion'
                                      return 'jsxTaggedRegion'
                                    else
                                      return 'jsxElement'
                                    endif
                                  elseif reversed[i+1] =~ 'jsxTaggedRegion'
                                    return 'jsxTaggedRegion'
                                  else
                                    return 'jsxElement'
                                  endif
    4              0.000001     endif
                            
    4              0.000003     let i = i + 1
    5              0.000003   endfor
                              
    1              0.000001   return 'Other'

FUNCTION  provider#python3#Call()
    Defined: /usr/share/nvim/runtime/autoload/provider/python3.vim line 26
Called 11 times
Total time:   0.031516
 Self time:   0.031516

count  total (s)   self (s)
   11              0.000023   if s:err != ''
                                return
   11              0.000004   endif
   11              0.000019   if !exists('s:host')
                                let s:rpcrequest = function('rpcrequest')
                            
                                " Ensure that we can load the Python3 host before bootstrapping
                                try
                                  let s:host = remote#host#Require('legacy-python3-provider')
                                catch
                                  let s:err = v:exception
                                  echohl WarningMsg
                                  echomsg v:exception
                                  echohl None
                                  return
                                endtry
   11              0.000004   endif
   11              0.031351   return call(s:rpcrequest, insert(insert(a:args, 'python_'.a:method), s:host))

FUNCTION  11()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/checker.vim line 68
Called 6 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    6              0.000013     return self._filetype . '/' . self._name

FUNCTION  12()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/checker.vim line 78
Called 6 times
Total time:   0.001715
 Self time:   0.001562

count  total (s)   self (s)
    6              0.000005     if a:0
                                    let self._exec = a:1
    6              0.000003     else
    6              0.000010         let suffix = self._name . '_exec'
    6   0.001676   0.001522         let self._exec = expand( syntastic#util#var(self._filetype . '_' . suffix, syntastic#util#var(suffix, self._exec_default)), 1 )
    6              0.000008     endif

FUNCTION  syntastic#util#stamp()
    Defined: ~/.config/nvim/plugged/syntastic/autoload/syntastic/util.vim line 407
Called 6 times
Total time:   0.000102
 Self time:   0.000102

count  total (s)   self (s)
    6              0.000100     return split( split(reltimestr(reltime(g:_SYNTASTIC_START)))[0], '\.' )

FUNCTION  ale#history#RememberOutput()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/history.vim line 58
Called 1 time
Total time:   0.000027
 Self time:   0.000007

count  total (s)   self (s)
    1   0.000025   0.000005     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
    1              0.000001     let l:obj.output = a:output

FUNCTION  ale#Var()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale.vim line 180
Called 293 times
Total time:   0.003228
 Self time:   0.003228

count  total (s)   self (s)
  293              0.000681     let l:full_name = 'ale_' . a:variable_name
  293              0.001228     let l:vars = getbufvar(str2nr(a:buffer), '', {})
                            
  293              0.001058     return get(l:vars, l:full_name, g:[l:full_name])

FUNCTION  <SNR>40_UpdateErrors()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic.vim line 389
Called 4 times
Total time:   0.039601
 Self time:   0.000371

count  total (s)   self (s)
    4   0.000058   0.000025     call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'version')
    4   0.000055   0.000024     call syntastic#log#debugShowOptions(g:_SYNTASTIC_DEBUG_TRACE, g:_SYNTASTIC_SHELL_OPTIONS)
    4   0.000049   0.000023     call syntastic#log#debugDump(g:_SYNTASTIC_DEBUG_VARIABLES)
    4   0.000059   0.000031     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'UpdateErrors' . (a:auto_invoked ? ' (auto)' : '') . ': ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
                            
    4   0.000075   0.000014     call s:modemap.synch()
                            
    4   0.014646   0.000021     if s:_skip_file(a:buf)
    1              0.000000         return
    3              0.000001     endif
                            
    3   0.000274   0.000034     let run_checks = !a:auto_invoked || s:modemap.doAutoChecking(a:buf)
    3              0.000002     if run_checks
    3   0.022153   0.000025         call s:CacheErrors(a:buf, a:checker_names)
    3   0.000029   0.000019         call syntastic#util#setLastTick(a:buf)
                                elseif a:auto_invoked
                                    return
    3              0.000001     endif
                            
    3   0.000065   0.000013     let loclist = g:SyntasticLoclist.current(a:buf)
                            
    3              0.000006     if exists('*SyntasticCheckHook')
                                    call SyntasticCheckHook(loclist.getRaw())
    3              0.000001     endif
                            
                                " populate loclist and jump {{{3
    3   0.000042   0.000012     let do_jump = syntastic#util#var('auto_jump') + 0
    3              0.000002     if do_jump == 2
                                    let do_jump = loclist.getFirstError(1)
    3              0.000002     elseif do_jump == 3
                                    let do_jump = loclist.getFirstError()
    3              0.000003     elseif 0 > do_jump || do_jump > 3
                                    let do_jump = 0
    3              0.000001     endif
                            
    3   0.000102   0.000014     if syntastic#util#var('always_populate_loc_list') || do_jump
    3   0.000194   0.000018         call loclist.setloclist(1)
    3              0.000005         if run_checks && do_jump && !loclist.isEmpty()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: jump')
                                        execute 'silent! lrewind ' . do_jump
                            
                                        " XXX: Vim doesn't call autocmd commands in a predictible
                                        " order, which can lead to missing filetype when jumping
                                        " to a new file; the following is a workaround for the
                                        " resulting brain damage
                                        if &filetype ==# ''
                                            silent! filetype detect
                                        endif
    3              0.000001         endif
    3              0.000001     endif
                                " }}}3
                            
    3   0.001714   0.000013     call s:notifiers.refresh(loclist)

FUNCTION  ale#ShouldDoNothing()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale.vim line 32
Called 55 times
Total time:   0.006647
 Self time:   0.004985

count  total (s)   self (s)
                                " The checks are split into separate if statements to make it possible to
                                " profile each check individually with Vim's profiling tools.
                                "
                                " Do nothing if ALE is disabled.
   55              0.000419     if !getbufvar(a:buffer, 'ale_enabled', get(g:, 'ale_enabled', 0))
                                    return 1
   55              0.000025     endif
                            
                                " Don't perform any checks when newer NeoVim versions are exiting.
   55              0.000192     if get(v:, 'exiting', v:null) isnot v:null
                                    return 1
   55              0.000021     endif
                            
   55              0.000251     let l:filetype = getbufvar(a:buffer, '&filetype')
                            
                                " Do nothing when there's no filetype.
   55              0.000078     if l:filetype is# ''
                                    return 1
   55              0.000021     endif
                            
                                " Do nothing for diff buffers.
   55              0.000136     if getbufvar(a:buffer, '&diff')
                                    return 1
   55              0.000020     endif
                            
                                " Do nothing for blacklisted files.
   55              0.000295     if index(get(g:, 'ale_filetype_blacklist', []), l:filetype) >= 0
                                    return 1
   55              0.000024     endif
                            
                                " Do nothing if running from command mode.
   55              0.000193     if s:getcmdwintype_exists && !empty(getcmdwintype())
                                    return 1
   55              0.000020     endif
                            
   55              0.000250     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
                                " Do nothing for directories.
   55              0.000070     if l:filename is# '.'
                                    return 1
   55              0.000022     endif
                            
                                " Don't start linting and so on when an operator is pending.
   55   0.000705   0.000438     if ale#util#Mode(1) is# 'no'
                                    return 1
   55              0.000025     endif
                            
                                " Do nothing if running in the sandbox.
   55   0.001277   0.000418     if ale#util#InSandbox()
                                    return 1
   55              0.000022     endif
                            
                                " Do nothing if the file is too large.
   55   0.000881   0.000345     if ale#FileTooLarge(a:buffer)
                                    return 1
   55              0.000021     endif
                            
                                " Do nothing from CtrlP buffers with CtrlP-funky.
   55              0.000387     if exists(':CtrlPFunky') is 2&& getbufvar(a:buffer, '&l:statusline') =~# 'CtrlPMode.*funky'
                                    return 1
   55              0.000023     endif
                            
   55              0.000037     return 0

FUNCTION  21()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/checker.vim line 192
Called 6 times
Total time:   0.001812
 Self time:   0.000097

count  total (s)   self (s)
    6   0.001748   0.000033     call self.syncExec()
                            
    6              0.000016     if !has_key(self, '_available')
                                    let self._available = {}
    6              0.000002     endif
    6              0.000011     if !has_key(self._available, self._exec)
                                    let self._available[self._exec] = self._isAvailableFunc()
    6              0.000002     endif
                            
    6              0.000009     return self._available[self._exec]

FUNCTION  29()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/cursor.vim line 15
Called 6 times
Total time:   0.000101
 Self time:   0.000042

count  total (s)   self (s)
    6   0.000085   0.000026     return syntastic#util#var('echo_current_error')

FUNCTION  <SNR>71_SkipFunc()
    Defined: ~/.config/nvim/plugged/vim-polyglot/indent/javascript.vim line 114
Called 7 times
Total time:   0.007888
 Self time:   0.000295

count  total (s)   self (s)
    7              0.000009   if s:top_col == 1
                                throw 'out of bounds'
    7              0.000005   elseif s:check_in
                                if eval(s:skip_expr)
                                  return 1
                                endif
                                let s:check_in = 0
    7              0.000094   elseif getline('.') =~ '\%<'.col('.').'c\/.\{-}\/\|\%>'.col('.').'c[''"]\|\\$'
                                if eval(s:skip_expr)
                                  return 1
                                endif
    7              0.000041   elseif search('\m`\|\${\|\*\/','nW'.s:z,s:looksyn)
    3   0.007636   0.000043     if eval(s:skip_expr)
                                  let s:check_in = 1
                                  return 1
    3              0.000001     endif
    4              0.000001   else
    4              0.000016     let s:synid_cache[:] += [[line2byte('.') + col('.') - 1], ['']]
    7              0.000003   endif
    7              0.000020   let [s:looksyn, s:top_col] = getpos('.')[1:2]

FUNCTION  <SNR>40_BufWritePostHook()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic.vim line 312
Called 4 times
Total time:   0.047743
 Self time:   0.000138

count  total (s)   self (s)
    4   0.008001   0.000049     let buf = syntastic#util#fname2buf(a:fname)
    4   0.000107   0.000053     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufWritePost, buffer ' . buf . ' = ' . string(a:fname))
    4   0.039630   0.000029     call s:UpdateErrors(buf, 1, [])

FUNCTION  ale#path#FindNearestFile()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/path.vim line 37
Called 160 times
Total time:   3.233212
 Self time:   3.233212

count  total (s)   self (s)
  160              0.359077     let l:buffer_filename = fnamemodify(bufname(a:buffer), ':p')
  160              0.001044     let l:buffer_filename = fnameescape(l:buffer_filename)
                            
  160              2.693805     let l:relative_path = findfile(a:filename, l:buffer_filename . ';')
                            
  160              0.000833     if !empty(l:relative_path)
   80              0.177557         return fnamemodify(l:relative_path, ':p')
   80              0.000068     endif
                            
   80              0.000075     return ''

FUNCTION  30()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/cursor.vim line 19
Called 3 times
Total time:   0.000075
 Self time:   0.000037

count  total (s)   self (s)
    3   0.000054   0.000015     if self.enabled() && !a:loclist.isEmpty()
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: refresh')
                                    let b:syntastic_private_messages = copy(a:loclist.messages(bufnr('')))
                                    let b:syntastic_private_line = -1
                                    let b:syntastic_cursor_columns = a:loclist.getCursorColumns()
                                    autocmd! syntastic CursorMoved
                                    autocmd syntastic CursorMoved * call SyntasticRefreshCursor()
    3              0.000001     endif

FUNCTION  31()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/cursor.vim line 31
Called 3 times
Total time:   0.000056
 Self time:   0.000036

count  total (s)   self (s)
    3   0.000035   0.000015     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: reset')
    3              0.000012     autocmd! syntastic CursorMoved
    3              0.000003     unlet! b:syntastic_private_messages
    3              0.000004     let b:syntastic_private_line = -1

FUNCTION  33()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/highlighting.vim line 28
Called 6 times
Total time:   0.000076
 Self time:   0.000025

count  total (s)   self (s)
    6   0.000075   0.000023     return s:has_highlighting && syntastic#util#var('enable_highlighting')

FUNCTION  34()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/highlighting.vim line 33
Called 3 times
Total time:   0.000176
 Self time:   0.000098

count  total (s)   self (s)
    3   0.000041   0.000007     if self.enabled()
    3   0.000034   0.000014         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: refresh')
    3   0.000025   0.000007         call self._reset()
    3              0.000004         let buf = bufnr('')
    3   0.000019   0.000014         let issues = filter(a:loclist.copyRaw(), 'v:val["bufnr"] == buf')
    3              0.000003         for item in issues
                                        let group = 'Syntastic' . get(item, 'subtype', '') . ( item['type'] ==? 'E' ? 'Error' : 'Warning' )
                            
                                        " The function `Syntastic_{filetype}_{checker}_GetHighlightRegex` is
                                        " used to override default highlighting.
                                        if has_key(item, 'hl')
                                            call matchadd(group, '\%' . item['lnum'] . 'l' . item['hl'])
                                        elseif get(item, 'col', 0)
                                            if get(item, 'vcol', 0)
                                                let lastcol = virtcol([item['lnum'], '$'])
                                                let coltype = 'v'
                                            else
                                                let lastcol = col([item['lnum'], '$'])
                                                let coltype = 'c'
                                            endif
                                            let lcol = min([lastcol, item['col']])
                            
                                            call matchadd(group, '\%' . item['lnum'] . 'l\%' . lcol . coltype)
                                        endif
    3              0.000002         endfor
    3              0.000001     endif

FUNCTION  35()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/highlighting.vim line 64
Called 3 times
Total time:   0.000073
 Self time:   0.000029

count  total (s)   self (s)
    3              0.000003     if s:has_highlighting
    3   0.000037   0.000013         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: reset')
    3   0.000030   0.000009         call self._reset()
    3              0.000001     endif

FUNCTION  37()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/highlighting.vim line 94
Called 6 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    6              0.000012     for match in getmatches()
                                    if stridx(match['group'], 'Syntastic') == 0
                                        call matchdelete(match['id'])
                                    endif
    6              0.000004     endfor

FUNCTION  38()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/loclist.vim line 10
Called 3 times
Total time:   0.000064
 Self time:   0.000064

count  total (s)   self (s)
    3              0.000018     let newObj = copy(self)
                            
    3              0.000008     let llist = filter(copy(a:rawLoclist), 'v:val["valid"]')
                            
    3              0.000003     for e in llist
                                    if get(e, 'type', '') ==# ''
                                        let e['type'] = 'E'
                                    endif
    3              0.000002     endfor
                            
    3              0.000004     let newObj._rawLoclist = llist
    3              0.000003     let newObj._name = ''
    3              0.000005     let newObj._owner = bufnr('')
    3              0.000002     let newObj._sorted = 0
    3              0.000004     let newObj._columns = g:syntastic_cursor_columns
                            
    3              0.000002     return newObj

FUNCTION  39()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/loclist.vim line 30
Called 210 times
Total time:   0.007174
 Self time:   0.005575

count  total (s)   self (s)
  210              0.001173     let buf = a:0 ? a:1 : bufnr('')
  210   0.003720   0.002121     let loclist = syntastic#util#getbufvar(buf, 'syntastic_loclist', {})
  210              0.000903     if type(loclist) != type({}) || empty(loclist)
                                    unlet! loclist
                                    let loclist = g:SyntasticLoclist.New([])
  210              0.000168     endif
  210              0.000209     return loclist

FUNCTION  <SNR>213_StartIfExecutable()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/lsp_linter.vim line 365
Called 20 times
Total time:   0.335624
 Self time:   0.000381

count  total (s)   self (s)
   20   0.000227   0.000106     if ale#command#IsDeferred(a:executable)
                                    let a:executable.result_callback = {   executable -> s:StartIfExecutable(a:options, executable)}
                            
                                    return 1
   20              0.000008     endif
                            
   20   0.335267   0.000146     if !ale#engine#IsExecutable(a:options.buffer, a:executable)
   20              0.000014         return 0
                                endif
                            
                                let l:command = ale#linter#GetCommand(a:options.buffer, a:options.linter)
                            
                                return s:StartWithCommand(a:options, a:executable, l:command)

FUNCTION  coc#util#get_complete_option()
    Defined: ~/.config/nvim/plugged/coc.nvim/autoload/coc/util.vim line 337
Called 2 times
Total time:   0.007660
 Self time:   0.007660

count  total (s)   self (s)
    2              0.000019   let pos = getcurpos()
    2              0.000007   let line = getline(pos[1])
    2              0.000024   let input = matchstr(strpart(line, 0, pos[2] - 1), '\k*$')
    2              0.000021   let col = pos[2] - strlen(input)
    2              0.002079   let synname = synIDattr(synID(pos[1], col, 1), 'name')
    2              0.005503   return { 'word': matchstr(strpart(line, col - 1), '^\k\+'), 'input': empty(input) ? '' : input, 'line': line, 'filetype': &filetype, 'filepath': expand('%:p'), 'bufnr': bufnr('%'), 'linenr': pos[1], 'colnr' : pos[2], 'col': col - 1, 'synname': synname, 'changedtick': b:changedtick, 'blacklist': get(b:, 'coc_suggest_blacklist', []),}

FUNCTION  ale#history#SetExitCode()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/history.vim line 49
Called 1 time
Total time:   0.000031
 Self time:   0.000010

count  total (s)   self (s)
    1   0.000027   0.000006     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
                                " If we find a match, then set the code and status.
    1              0.000002     let l:obj.exit_code = a:exit_code
    1              0.000001     let l:obj.status = 'finished'

FUNCTION  ale#command#ResetCwd()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/command.vim line 39
Called 21 times
Total time:   0.000124
 Self time:   0.000124

count  total (s)   self (s)
   21              0.000053     if has_key(s:buffer_data, a:buffer)
   21              0.000051         let s:buffer_data[a:buffer].cwd = v:null
   21              0.000009     endif

FUNCTION  <SNR>260_WinFindBuf()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/list.vim line 80
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000006     return exists('*win_findbuf') ? win_findbuf(str2nr(a:buffer)) : [0]

FUNCTION  ale#util#Writefile()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/util.vim line 431
Called 20 times
Total time:   0.006778
 Self time:   0.006778

count  total (s)   self (s)
   20              0.005448     let l:corrected_lines = getbufvar(a:buffer, '&fileformat') is# 'dos'   ? map(copy(a:lines), 'substitute(v:val, ''\r*$'', ''\r'', '''')')   : a:lines
                            
                                " Set binary flag if buffer doesn't have eol and nofixeol to avoid appending newline
   20              0.000159     let l:flags = !getbufvar(a:buffer, '&eol') && exists('+fixeol') && !&fixeol ? 'bS' : 'S'
                            
   20              0.001133     call writefile(l:corrected_lines, a:filename, l:flags) " no-custom-checks

FUNCTION  42()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/loclist.vim line 56
Called 12 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
   12              0.000014     return empty(self._rawLoclist)

FUNCTION  44()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/loclist.vim line 68
Called 3 times
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    3              0.000004     return copy(self._rawLoclist)

FUNCTION  45()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/loclist.vim line 72
Called 3 times
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    3              0.000002     return self._rawLoclist

FUNCTION  48()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/loclist.vim line 84
Called 204 times
Total time:   0.011850
 Self time:   0.011850

count  total (s)   self (s)
  204              0.000667     if !exists('self._stl_format')
    3              0.000006         let self._stl_format = ''
  204              0.000102     endif
  204              0.000403     if !exists('self._stl_flag')
    3              0.000004         let self._stl_flag = ''
  204              0.000088     endif
                            
  204              0.000412     if g:syntastic_stl_format !=# self._stl_format
    3              0.000005         let self._stl_format = g:syntastic_stl_format
                            
    3              0.000005         if !empty(self._rawLoclist)
                                        let errors = self.errors()
                                        let warnings = self.warnings()
                            
                                        let num_errors = len(errors)
                                        let num_warnings = len(warnings)
                                        let num_issues = len(self._rawLoclist)
                            
                                        let output = self._stl_format
                            
                                        "hide stuff wrapped in %E(...) unless there are errors
                                        let output = substitute(output, '\m\C%E{\([^}]*\)}', num_errors ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %W(...) unless there are warnings
                                        let output = substitute(output, '\m\C%W{\([^}]*\)}', num_warnings ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %B(...) unless there are both errors and warnings
                                        let output = substitute(output, '\m\C%B{\([^}]*\)}', (num_warnings && num_errors) ? '\1' : '' , 'g')
                            
                                        let flags = { '%':  '%', 't':  num_issues, 'e':  num_errors, 'w':  num_warnings, 'N':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':t') : ''), 'P':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':p:~:.') : ''), 'F':  (num_issues ? self._rawLoclist[0]['lnum'] : ''), 'ne': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':t') : ''), 'pe': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':p:~:.') : ''), 'fe': (num_errors ? errors[0]['lnum'] : ''), 'nw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':t') : ''), 'pw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':p:~:.') : ''), 'fw': (num_warnings ? warnings[0]['lnum'] : '') }
                                        let output = substitute(output, '\v\C\%(-?\d*%(\.\d+)?)([npf][ew]|[NPFtew%])', '\=syntastic#util#wformat(submatch(1), flags[submatch(2)])', 'g')
                            
                                        let self._stl_flag = output
    3              0.000003         else
    3              0.000003             let self._stl_flag = ''
    3              0.000001         endif
  204              0.000095     endif
                            
  204              0.000301     return self._stl_flag

FUNCTION  AutoPairsDelete()
    Defined: ~/.config/nvim/plugged/auto-pairs/plugin/auto-pairs.vim line 303
Called 2 times
Total time:   0.000416
 Self time:   0.000329

count  total (s)   self (s)
    2              0.000016   if !b:autopairs_enabled
                                return "\<BS>"
    2              0.000003   end
                            
    2   0.000112   0.000025   let [before, after, ig] = s:getline()
   20              0.000031   for [open, close, opt] in b:AutoPairsList
   18              0.000061     let b = matchstr(before, '\V'.open.'\v\s?$')
   18              0.000052     let a = matchstr(after, '^\v\s*\V'.close)
   18              0.000015     if b != '' && a != ''
                                  if b[-1:-1] == ' '
                                    if a[0] == ' '
                                      return "\<BS>\<DELETE>"
                                    else
                                      return "\<BS>"
                                    end
                                  end
                                  return s:backspace(b).s:delete(a)
   18              0.000005     end
   20              0.000008   endfor
                            
    2              0.000003   return "\<BS>"
                              " delete the pair foo[]| <BS> to foo
                              for [open, close, opt] in b:AutoPairsList
                                let m = s:matchend(before, '\V'.open.'\v\s*'.'\V'.close.'\v$')
                                if len(m) > 0
                                  return s:backspace(m[2])
                                end
                              endfor
                              return "\<BS>"

FUNCTION  <SNR>200_GetAliasedFiletype()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/linter.vim line 294
Called 20 times
Total time:   0.000698
 Self time:   0.000698

count  total (s)   self (s)
   20              0.000072     let l:buffer_aliases = get(b:, 'ale_linter_aliases', {})
                            
                                " b:ale_linter_aliases can be set to a List or String.
   20              0.000078     if type(l:buffer_aliases) is v:t_list|| type(l:buffer_aliases) is v:t_string
                                    return l:buffer_aliases
   20              0.000009     endif
                            
                                " Check for aliased filetypes first in a buffer variable,
                                " then the global variable,
                                " then in the default mapping,
                                " otherwise use the original filetype.
   60              0.000131     for l:dict in [   l:buffer_aliases,   g:ale_linter_aliases,   s:default_ale_linter_aliases,]
   60              0.000129         if has_key(l:dict, a:original_filetype)
   20              0.000051             return l:dict[a:original_filetype]
   40              0.000017         endif
   40              0.000025     endfor
                            
                                return a:original_filetype

FUNCTION  ale#cursor#EchoCursorWarning()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/cursor.vim line 63
Called 39 times
Total time:   0.020877
 Self time:   0.003813

count  total (s)   self (s)
   39              0.000408     let l:buffer = bufnr('')
                            
   39              0.000111     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
   39              0.000043     endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
   39              0.000154     if mode(1) isnot# 'n'
    6              0.000005         return
   33              0.000015     endif
                            
   33   0.004778   0.000331     if ale#ShouldDoNothing(l:buffer)
                                    return
   33              0.000014     endif
                            
   33   0.004725   0.000366     let [l:info, l:loc] = ale#util#FindItemAtCursor(l:buffer)
                            
   33              0.000041     if g:ale_echo_cursor
   33              0.000062         if !empty(l:loc)
   28   0.000521   0.000202             let l:format = ale#Var(l:buffer, 'echo_msg_format')
   28   0.001835   0.000222             let l:msg = ale#GetLocItemMessage(l:loc, l:format)
   28   0.006553   0.000229             call ale#cursor#TruncatedEcho(l:msg)
   28              0.000053             let l:info.echoed = 1
    5              0.000023         elseif get(l:info, 'echoed')
                                        " We'll only clear the echoed message when moving off errors once,
                                        " so we don't continually clear the echo line.
    5              0.000472             execute 'echo'
    5              0.000052             let l:info.echoed = 0
   33              0.000021         endif
   33              0.000018     endif
                            
   33              0.000063     if g:ale_cursor_detail
                                    if !empty(l:loc)
                                        call s:ShowCursorDetailForItem(l:loc, {'stay_here': 1})
                                    else
                                        call ale#preview#CloseIfTypeMatches('ale-preview')
                                    endif
   33              0.000021     endif

FUNCTION  53()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/loclist.vim line 166
Called 3 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    3              0.000009     let self._owner = type(a:buffer) == type(0) ? a:buffer : str2nr(a:buffer)

FUNCTION  55()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/loclist.vim line 177
Called 3 times
Total time:   0.000109
 Self time:   0.000028

count  total (s)   self (s)
    6   0.000095   0.000013     for buf in self.getBuffers()
    3              0.000007         call setbufvar(buf, 'syntastic_loclist', {})
    6              0.000002     endfor

FUNCTION  ale#GetLocItemMessage()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale.vim line 239
Called 49 times
Total time:   0.002340
 Self time:   0.002340

count  total (s)   self (s)
   49              0.000063     let l:msg = a:format_string
   49              0.000072     let l:severity = g:ale_echo_msg_warning_str
   49              0.000098     let l:code = get(a:item, 'code', '')
   49              0.000083     let l:type = get(a:item, 'type', 'E')
   49              0.000099     let l:linter_name = get(a:item, 'linter_name', '')
   49              0.000122     let l:code_repl = !empty(l:code) ? '\=submatch(1) . l:code . submatch(2)' : ''
                            
   49              0.000047     if l:type is# 'E'
                                    let l:severity = g:ale_echo_msg_error_str
   49              0.000044     elseif l:type is# 'I'
                                    let l:severity = g:ale_echo_msg_info_str
   49              0.000019     endif
                            
                                " Replace special markers with certain information.
                                " \=l:variable is used to avoid escaping issues.
   49              0.000676     let l:msg = substitute(l:msg, '\v\%([^\%]*)code([^\%]*)\%', l:code_repl, 'g')
   49              0.000203     let l:msg = substitute(l:msg, '\V%severity%', '\=l:severity', 'g')
   49              0.000158     let l:msg = substitute(l:msg, '\V%linter%', '\=l:linter_name', 'g')
                                " Replace %s with the text.
   49              0.000191     let l:msg = substitute(l:msg, '\V%s', '\=a:item.text', 'g')
                                " Windows may insert carriage return line endings (^M), strip these characters.
   49              0.000146     let l:msg = substitute(l:msg, '\r', '', 'g')
                            
   49              0.000041     return l:msg

FUNCTION  ale#events#QuitEvent()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/events.vim line 14
Called 1 time
Total time:   0.000023
 Self time:   0.000015

count  total (s)   self (s)
                                " Remember when ALE is quitting for BufWrite, etc.
    1   0.000021   0.000013     call setbufvar(a:buffer, 'ale_quitting', ale#events#ClockMilliseconds())

FUNCTION  <SNR>253_syntax_stack_at()
    Defined: ~/.config/nvim/plugged/vim-polyglot/autoload/jsx_pretty/indent.vim line 25
Called 1 time
Total time:   0.000469
 Self time:   0.000469

count  total (s)   self (s)
    1              0.000468   return map(synstack(a:lnum, a:col), 'synIDattr(v:val, "name")')

FUNCTION  ale#list#SetLists()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/list.vim line 189
Called 1 time
Total time:   0.004170
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000004     if get(g:, 'ale_set_lists_synchronously') == 1|| getbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Update lists immediately if running a test synchronously, or if the
                                    " buffer was saved.
                                    "
                                    " The lists need to be updated immediately when saving a buffer so
                                    " that we can reliably close window automatically, if so configured.
    1   0.004162   0.000006         call s:SetListsImpl(-1, a:buffer, a:loclist)
                                else
                                    call ale#util#StartPartialTimer(   0,   function('s:SetListsImpl'),   [a:buffer, a:loclist],)
    1              0.000000     endif

FUNCTION  ale#sign#SetSigns()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/sign.vim line 419
Called 1 time
Total time:   0.002806
 Self time:   0.000069

count  total (s)   self (s)
    1              0.000002     if !bufexists(str2nr(a:buffer))
                                    " Stop immediately when attempting to set signs for a buffer which
                                    " does not exist.
                                    return
    1              0.000000     endif
                            
                                " Find the current markers
    1   0.000767   0.000008     let [l:is_dummy_sign_set, l:current_sign_list] =   ale#sign#FindCurrentSigns(a:buffer)
                            
                                " Update the line numbers for items from before which may have moved.
    1   0.000189   0.000011     call s:UpdateLineNumbers(a:buffer, l:current_sign_list, a:loclist)
                            
                                " Group items after updating the line numbers.
    1   0.000150   0.000007     let l:grouped_items = s:GroupLoclistItems(a:buffer, a:loclist)
                            
                                " Build a map of current and new signs, with the lines as the keys.
    1   0.001157   0.000007     let l:sign_map = s:BuildSignMap(   a:buffer,   l:current_sign_list,   l:grouped_items,)
                            
    1   0.000513   0.000008     let l:command_list = ale#sign#GetSignCommands(   a:buffer,   l:is_dummy_sign_set,   l:sign_map,)
                            
                                " Change the sign column color if the option is on.
    1              0.000002     if g:ale_change_sign_column_color && !empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithErrors
    1              0.000000     endif
                            
    5              0.000003     for l:command in l:command_list
    4              0.000009         silent! execute l:command
    5              0.000002     endfor
                            
                                " Reset the sign column color when there are no more errors.
    1              0.000001     if g:ale_change_sign_column_color && empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithoutErrors
    1              0.000000     endif

FUNCTION  ale#engine#InitBufferInfo()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/engine.vim line 82
Called 20 times
Total time:   0.000197
 Self time:   0.000197

count  total (s)   self (s)
   20              0.000055     if !has_key(g:ale_buffer_info, a:buffer)
                                    " active_linter_list will hold the list of active linter names
                                    " loclist holds the loclist items after all jobs have completed.
                                    let g:ale_buffer_info[a:buffer] = {   'active_linter_list': [],   'active_other_sources_list': [],   'loclist': [],}
                            
                                    return 1
   20              0.000012     endif
                            
   20              0.000014     return 0

FUNCTION  <SNR>71_IsBlock()
    Defined: ~/.config/nvim/plugged/vim-polyglot/indent/javascript.vim line 323
Called 1 time
Total time:   0.000075
 Self time:   0.000030

count  total (s)   self (s)
    1   0.000049   0.000004   let tok = s:PreviousToken()
    1              0.000010   if join(s:stack) =~? 'xml\|jsx' && s:SynAt(line('.'),col('.')-1) =~? 'xml\|jsx'
                                let s:in_jsx = 1
                                return tok != '{'
    1              0.000002   elseif tok =~ '\k'
                                if tok ==# 'type'
                                  return s:Pure('eval',"s:PreviousToken() !~# '^\\%(im\\|ex\\)port$' || s:PreviousToken() == '.'")
                                elseif tok ==# 'of'
                                  return s:Pure('eval',"!s:GetPair('[[({]','[])}]','bW',s:skip_expr) || s:LookingAt() != '(' ||" ."s:{s:PreviousToken() ==# 'await' ? 'Previous' : ''}Token() !=# 'for' || s:PreviousToken() == '.'")
                                endif
                                return index(split('return const let import export extends yield default delete var await void typeof throw case new in instanceof') ,tok) < (line('.') != a:firstline) || s:Pure('s:PreviousToken') == '.'
    1              0.000001   elseif tok == '>'
    1              0.000003     return getline('.')[col('.')-2] == '=' || s:SynAt(line('.'),col('.')) =~? 'jsflow\|^html'
                              elseif tok == '*'
                                return s:Pure('s:PreviousToken') == ':'
                              elseif tok == ':'
                                return s:Pure('eval',"s:PreviousToken() =~ '^\\K\\k*$' && !s:ExprCol()")
                              elseif tok == '/'
                                return s:SynAt(line('.'),col('.')) =~? 'regex'
                              elseif tok !~ '[=~!<,.?^%|&([]'
                                return tok !~ '[-+]' || line('.') != a:firstline && getline('.')[col('.')-2] == tok
                              endif

FUNCTION  <SNR>211_GetLintFileSlots()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/engine.vim line 591
Called 20 times
Total time:   0.000679
 Self time:   0.000679

count  total (s)   self (s)
   20              0.000048     let l:linter_slots = []
                            
   60              0.000076     for l:linter in a:linters
   40              0.000061         let l:LintFile = l:linter.lint_file
                            
   40              0.000078         if type(l:LintFile) is v:t_func
                                        let l:LintFile = l:LintFile(a:buffer)
   40              0.000016         endif
                            
   40              0.000098         call add(l:linter_slots, [l:LintFile, l:linter])
   60              0.000036     endfor
                            
   20              0.000020     return l:linter_slots

FUNCTION  63()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/loclist.vim line 292
Called 3 times
Total time:   0.000176
 Self time:   0.000128

count  total (s)   self (s)
    3              0.000008     if !exists('w:syntastic_loclist_set')
                                    let w:syntastic_loclist_set = []
    3              0.000001     endif
    3              0.000011     if a:new || empty(w:syntastic_loclist_set) || w:syntastic_loclist_set != [self._owner, getbufvar(self._owner, 'changedtick')]
    3              0.000007         let replace = !a:new && g:syntastic_reuse_loc_lists && !empty(w:syntastic_loclist_set)
    3   0.000054   0.000019         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: setloclist ' . (replace ? '(replace)' : '(new)'))
    3   0.000022   0.000019         call setloclist(0, self.getRaw(), replace ? 'r' : ' ')
    3              0.000003         try
                                        " Vim 7.4.2200 or later
    3              0.000013             call setloclist(0, [], 'r', { 'title': ':SyntasticCheck ' . self._name })
                                    catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                        " do nothing
    3              0.000003         endtry
    3   0.000022   0.000012         call syntastic#util#setLastTick(self._owner)
    3              0.000008         let w:syntastic_loclist_set = [self._owner, getbufvar(self._owner, 'syntastic_lasttick')]
    3              0.000001     endif

FUNCTION  66()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/modemap.vim line 19
Called 4 times
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
    4              0.000007     if exists('g:syntastic_mode_map')
                                    let self._mode = get(g:syntastic_mode_map, 'mode', 'active')
                                    let self._activeFiletypes = copy(get(g:syntastic_mode_map, 'active_filetypes', []))
                                    let self._passiveFiletypes = copy(get(g:syntastic_mode_map, 'passive_filetypes', []))
    4              0.000002     else
    4              0.000005         let self._mode = 'active'
    4              0.000008         let self._activeFiletypes = []
    4              0.000004         let self._passiveFiletypes = []
    4              0.000002     endif

FUNCTION  67()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/modemap.vim line 31
Called 3 times
Total time:   0.000196
 Self time:   0.000062

count  total (s)   self (s)
    3   0.000037   0.000017     let registry = g:SyntasticRegistry.Instance()
    3   0.000102   0.000014     let fts = registry.resolveFiletypes(a:filetype)
                            
    3   0.000016   0.000011     if self.isPassive()
                                    return self._isOneFiletypeActive(fts)
    3              0.000002     else
    3   0.000030   0.000010         return self._noFiletypesArePassive(fts)
                                endif

FUNCTION  68()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/modemap.vim line 42
Called 3 times
Total time:   0.000240
 Self time:   0.000044

count  total (s)   self (s)
    3              0.000011     let local_mode = getbufvar(a:buf, 'syntastic_mode')
    3              0.000005     if local_mode ==# 'active' || local_mode ==# 'passive'
                                    return local_mode ==# 'active'
    3              0.000001     endif
                            
    3   0.000217   0.000021     return self.allowsAutoChecking(getbufvar(a:buf, '&filetype'))

FUNCTION  69()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/modemap.vim line 51
Called 3 times
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    3              0.000004     return self._mode ==# 'passive'

FUNCTION  <SNR>262_GetCallbacks()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/fix.vim line 264
Called 3 times
Total time:   0.000515
 Self time:   0.000369

count  total (s)   self (s)
    3              0.000009     if len(a:fixers)
                                    let l:callback_list = a:fixers
    3              0.000013     elseif type(get(b:, 'ale_fixers')) is v:t_list
                                    " Lists can be used for buffer-local variables only
                                    let l:callback_list = b:ale_fixers
    3              0.000002     else
                                    " buffer and global options can use dictionaries mapping filetypes to
                                    " callbacks to run.
    3   0.000058   0.000021         let l:fixers = ale#Var(a:buffer, 'fixers')
    3              0.000006         let l:callback_list = []
    3              0.000004         let l:matched = 0
                            
    6              0.000034         for l:sub_type in split(&filetype, '\.')
    3   0.000067   0.000032             if s:AddSubCallbacks(l:callback_list, get(l:fixers, l:sub_type))
                                            let l:matched = 1
    3              0.000002             endif
    6              0.000006         endfor
                            
                                    " If we couldn't find fixers for a filetype, default to '*' fixers.
    3              0.000007         if !l:matched
    3   0.000075   0.000039             call s:AddSubCallbacks(l:callback_list, get(l:fixers, '*'))
    3              0.000002         endif
    3              0.000002     endif
                            
    3              0.000005     if a:fixing_flag is# 'save_file'
    3   0.000062   0.000023         let l:config = ale#Var(a:buffer, 'fix_on_save_ignore')
                            
    3              0.000006         if !empty(l:config)
                                        call s:IgnoreFixers(l:callback_list, &filetype, l:config)
    3              0.000002         endif
    3              0.000002     endif
                            
    3              0.000006     let l:corrected_list = []
                            
                                " Variables with capital characters are needed, or Vim will complain about
                                " funcref variables.
    3              0.000007     for l:Item in l:callback_list
                                    " Try to capture the names of registered fixer names, so we can use
                                    " them for filename mapping or other purposes later.
                                    let l:fixer_name = v:null
                            
                                    if type(l:Item) is v:t_string
                                        let l:Func = ale#fix#registry#GetFunc(l:Item)
                            
                                        if !empty(l:Func)
                                            let l:fixer_name = l:Item
                                            let l:Item = l:Func
                                        endif
                                    endif
                            
                                    try
                                        call add(l:corrected_list, [   l:fixer_name,   ale#util#GetFunction(l:Item)])
                                    catch /E475/
                                        " Rethrow exceptions for failing to get a function so we can print
                                        " a friendly message about it.
                                        throw 'BADNAME ' . v:exception
                                    endtry
    3              0.000005     endfor
                            
    3              0.000005     return l:corrected_list

FUNCTION  ale#engine#MarkLinterInactive()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/engine.vim line 43
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004     call filter(a:info.active_linter_list, 'v:val.name isnot# a:linter_name')

FUNCTION  <SNR>253_is_jsx_region()
    Defined: ~/.config/nvim/plugged/vim-polyglot/autoload/jsx_pretty/indent.vim line 66
Called 4 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    4              0.000008   return a:syntax =~? 'jsxRegion'

FUNCTION  <SNR>40__ignore_file()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic.vim line 705
Called 6 times
Total time:   0.015084
 Self time:   0.015084

count  total (s)   self (s)
    6              0.014990     let fname = fnamemodify(a:filename, ':p')
    6              0.000043     for pattern in g:syntastic_ignore_files
                                    if fname =~# pattern
                                        return 1
                                    endif
    6              0.000008     endfor
    6              0.000006     return 0

FUNCTION  74()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/modemap.vim line 112
Called 3 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    3              0.000019     return empty(filter(copy(a:filetypes), 'index(self._passiveFiletypes, v:val) != -1'))

FUNCTION  76()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/notifiers.vim line 25
Called 3 times
Total time:   0.001701
 Self time:   0.000561

count  total (s)   self (s)
    3   0.000074   0.000028     if !syntastic#util#bufIsActive(bufnr('')) || (!a:loclist.isEmpty() && !a:loclist.isNewerThan([]))
                                    " loclist not fully constructed yet
                                    return
    3              0.000001     endif
                            
    3   0.000031   0.000012     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: refresh')
   18              0.000015     for type in self._enabled_types
   15              0.000090         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
   15   0.000283   0.000095         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
   12              0.000024             if index(s:_PERSISTENT_NOTIFIERS, type) > -1
                                            " refresh only if loclist has changed since last call
    3              0.000007                 if !exists('b:syntastic_private_' . type . '_stamp')
                                                let b:syntastic_private_{type}_stamp = []
    3              0.000001                 endif
    3   0.000078   0.000017                 if a:loclist.isNewerThan(b:syntastic_private_{type}_stamp) || a:loclist.isEmpty()
    3   0.000270   0.000014                     call self._notifier[type].refresh(a:loclist)
    3   0.000053   0.000018                     let b:syntastic_private_{type}_stamp = syntastic#util#stamp()
    3              0.000001                 endif
    9              0.000003             else
    9   0.000585   0.000048                 call self._notifier[type].refresh(a:loclist)
   12              0.000004             endif
   15              0.000004         endif
   18              0.000009     endfor

FUNCTION  77()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/notifiers.vim line 51
Called 3 times
Total time:   0.000505
 Self time:   0.000307

count  total (s)   self (s)
    3   0.000035   0.000013     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: reset')
   18              0.000016     for type in self._enabled_types
   15              0.000081         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
                            
                                    " reset notifiers regardless if they are enabled or not, since
                                    " the user might have disabled them since the last refresh();
                                    " notifiers MUST be prepared to deal with reset() when disabled
   15              0.000037         if has_key(g:{class}, 'reset')
    9   0.000217   0.000041             call self._notifier[type].reset(a:loclist)
   15              0.000005         endif
                            
                                    " also reset stamps
   15              0.000026         if index(s:_PERSISTENT_NOTIFIERS, type) > -1
    6              0.000017             let b:syntastic_private_{type}_stamp = []
   15              0.000004         endif
   18              0.000009     endfor

FUNCTION  79()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/registry.vim line 163
Called 3 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    3              0.000007     if !exists('s:SyntasticRegistryInstance')
                                    let s:SyntasticRegistryInstance = copy(self)
                                    let s:SyntasticRegistryInstance._checkerMap = {}
    3              0.000001     endif
                            
    3              0.000003     return s:SyntasticRegistryInstance

FUNCTION  ale#engine#IsCheckingBuffer()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/engine.vim line 101
Called 22 times
Total time:   0.000272
 Self time:   0.000272

count  total (s)   self (s)
   22              0.000114     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
   22              0.000121     return !empty(get(l:info, 'active_linter_list', []))   || !empty(get(l:info, 'active_other_sources_list', []))

FUNCTION  ale#job#ValidateArguments()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/job.vim line 144
Called 20 times
Total time:   0.000080
 Self time:   0.000080

count  total (s)   self (s)
   20              0.000039     if a:options.mode isnot# 'nl' && a:options.mode isnot# 'raw'
                                    throw 'Invalid mode: ' . a:options.mode
   20              0.000007     endif

FUNCTION  ale#engine#MarkLinterActive()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/engine.vim line 28
Called 20 times
Total time:   0.000245
 Self time:   0.000245

count  total (s)   self (s)
   20              0.000024     let l:found = 0
                            
   20              0.000055     for l:other_linter in a:info.active_linter_list
                                    if l:other_linter.name is# a:linter.name
                                        let l:found = 1
                                        break
                                    endif
   20              0.000015     endfor
                            
   20              0.000014     if !l:found
   20              0.000036         call add(a:info.active_linter_list, a:linter)
   20              0.000006     endif

FUNCTION  <SNR>17_SyncAutocmd()
    Defined: ~/.config/nvim/plugged/coc.nvim/plugin/coc.vim line 238
Called 4 times
Total time:   0.007554
 Self time:   0.000065

count  total (s)   self (s)
    4              0.000008   if !g:coc_workspace_initialized
                                return
    4              0.000003   endif
    4              0.000004   if g:coc_service_initialized
    4   0.007519   0.000029     call coc#rpc#request('CocAutocmd', a:000)
                              else
                                call coc#rpc#notify('CocAutocmd', a:000)
    4              0.000001   endif

FUNCTION  <SNR>253_is_jsx_brace()
    Defined: ~/.config/nvim/plugged/vim-polyglot/autoload/jsx_pretty/indent.vim line 81
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002   return a:syntax =~? 'jsxBraces'

FUNCTION  ale#job#Stop()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/job.vim line 346
Called 19 times
Total time:   0.001073
 Self time:   0.001073

count  total (s)   self (s)
   19              0.000049     if !has_key(s:job_map, a:job_id)
                                    return
   19              0.000008     endif
                            
   19              0.000098     if has('nvim')
                                    " FIXME: NeoVim kills jobs on a timer, but will not kill any processes
                                    " which are child processes on Unix. Some work needs to be done to
                                    " kill child processes to stop long-running processes like pylint.
   19              0.000597         silent! call jobstop(a:job_id)
                                else
                                    let l:job = s:job_map[a:job_id].job
                            
                                    " We must close the channel for reading the buffer if it is open
                                    " when stopping a job. Otherwise, we will get errors in the status line.
                                    if ch_status(job_getchannel(l:job)) is# 'open'
                                        call ch_close_in(job_getchannel(l:job))
                                    endif
                            
                                    " Ask nicely for the job to stop.
                                    call job_stop(l:job)
                            
                                    if ale#job#IsRunning(l:job)
                                        " Set a 100ms delay for killing the job with SIGKILL.
                                        let s:job_kill_timers[timer_start(100, function('s:KillHandler'))] = l:job
                                    endif
   19              0.000008     endif

FUNCTION  <SNR>253_start_syntax()
    Defined: ~/.config/nvim/plugged/vim-polyglot/autoload/jsx_pretty/indent.vim line 40
Called 1 time
Total time:   0.000022
 Self time:   0.000012

count  total (s)   self (s)
    1   0.000022   0.000012   return s:syntax_at(a:lnum, s:start_col(a:lnum))

FUNCTION  ale#command#FormatCommand()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/command.vim line 200
Called 20 times
Total time:   0.055945
 Self time:   0.044718

count  total (s)   self (s)
   20              0.000024     let l:temporary_file = ''
   20              0.000023     let l:command = a:command
                            
   20              0.000023     if !empty(a:cwd)
   20   0.000821   0.000122         let l:command = ale#command#CdString(a:cwd) . l:command
   20              0.000008     endif
                            
                                " First replace all uses of %%, used for literal percent characters,
                                " with an ugly string.
   20              0.000090     let l:command = substitute(l:command, '%%', '<<PERCENTS>>', 'g')
                            
                                " Replace %e with the escaped executable, if available.
   20              0.000054     if !empty(a:executable) && l:command =~# '%e'
                                    let l:command = substitute(l:command, '%e', '\=ale#Escape(a:executable)', 'g')
   20              0.000006     endif
                            
                                " Replace all %s occurrences in the string with the name of the current
                                " file.
   20              0.000025     if l:command =~# '%s'
   20              0.042841         let l:filename = fnamemodify(bufname(a:buffer), ':p')
   20   0.001060   0.000503         let l:command = substitute(   l:command,   s:path_format_regex,   '\=s:FormatFilename(l:filename, a:mappings, submatch(1))',   'g')
   20              0.000010     endif
                            
   20              0.000083     if a:input isnot v:false && l:command =~# '%t'
                                    " Create a temporary filename, <temp_dir>/<original_basename>
                                    " The file itself will not be created by this function.
                                    let l:temporary_file = s:TemporaryFilename(a:buffer)
                                    let l:command = substitute(   l:command,   '\v\%t(%(:h|:t|:r|:e)*)',   '\=s:FormatFilename(l:temporary_file, a:mappings, submatch(1))',   'g')
   20              0.000007     endif
                            
                                " Finish formatting so %% becomes %.
   20              0.000088     let l:command = substitute(l:command, '<<PERCENTS>>', '%', 'g')
                            
   20              0.000037     if a:pipe_file_if_needed && empty(l:temporary_file)
                                    " If we are to send the Vim buffer to a command, we'll do it
                                    " in the shell. We'll write out the file to a temporary file,
                                    " and then read it back in, in the shell.
   20   0.000857   0.000121         let l:temporary_file = s:TemporaryFilename(a:buffer)
   20   0.000289   0.000112         let l:command = l:command . ' < ' . ale#Escape(l:temporary_file)
   20              0.000008     endif
                            
   20   0.009279   0.000220     let l:file_created = ale#command#CreateTempFile(   a:buffer,   l:temporary_file,   a:input,)
                            
   20              0.000047     return [l:temporary_file, l:command, l:file_created]

FUNCTION  81()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/registry.vim line 195
Called 3 times
Total time:   0.000781
 Self time:   0.000300

count  total (s)   self (s)
    3   0.000112   0.000016     let ftlist = self.resolveFiletypes(a:ftalias)
                            
    3              0.000025     let names = !empty(a:hints_list) ? a:hints_list : exists('b:syntastic_checkers') ? b:syntastic_checkers : []
                            
    3              0.000003     let cnames = []
    3              0.000004     if !empty(names)
                                    for name in names
                                        if name !~# '/'
                                            for ft in ftlist
                                                call add(cnames, ft . '/' . name)
                                            endfor
                                        else
                                            call add(cnames, name)
                                        endif
                                    endfor
    3              0.000002     else
    6              0.000007         for ft in ftlist
    3   0.000085   0.000017             call self._sanityCheck(ft)
    3              0.000017             let defs = exists('g:syntastic_' . ft . '_checkers') ? g:syntastic_{ft}_checkers : get(s:_DEFAULT_CHECKERS, ft, [])
    3              0.000037             call extend(cnames, map(copy(defs), 'stridx(v:val, "/") < 0 ? ft . "/" . v:val : v:val' ))
    6              0.000004         endfor
    3              0.000002     endif
    3   0.000118   0.000025     let cnames = syntastic#util#unique(cnames)
                            
    6   0.000117   0.000043     for ft in syntastic#util#unique(map( copy(cnames), 'v:val[: stridx(v:val, "/")-1]' ))
    3   0.000028   0.000015         call self._loadCheckersFor(ft, 0)
    6              0.000003     endfor
                            
    3   0.000153   0.000015     return self._filterCheckersByName(cnames)

FUNCTION  86()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/registry.vim line 265
Called 6 times
Total time:   0.000184
 Self time:   0.000115

count  total (s)   self (s)
    6   0.000182   0.000113     return map(split( get(g:syntastic_filetype_map, a:ftalias, a:ftalias), '\m\.' ), 's:_normalise_filetype(v:val)')

FUNCTION  89()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/registry.vim line 348
Called 6 times
Total time:   0.000088
 Self time:   0.000088

count  total (s)   self (s)
    6              0.000018     let sep_idx = stridx(a:cname, '/')
    6              0.000007     if sep_idx > 0
    6              0.000012         let ft = a:cname[: sep_idx-1]
    6              0.000011         let name = a:cname[sep_idx+1 :]
                                else
                                    let ft = &filetype
                                    let name = a:cname
    6              0.000003     endif
    6              0.000019     return get(self._checkerMap[ft], name, {})

FUNCTION  ale#command#Run()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/command.vim line 333
Called 20 times
Total time:   0.072890
 Self time:   0.003001

count  total (s)   self (s)
   20              0.000046     let l:options = get(a:000, 0, {})
                            
   20              0.000034     if len(a:000) > 1
                                    throw 'Too many arguments!'
   20              0.000007     endif
                            
   20              0.000042     let l:output_stream = get(l:options, 'output_stream', 'stdout')
   20              0.000021     let l:line_list = []
   20              0.000036     let l:cwd = get(l:options, 'cwd', v:null)
                            
   20              0.000019     if l:cwd is v:null
                                    " Default the working directory to whatever it was for the last
                                    " command run in the chain.
                                    let l:cwd = get(get(s:buffer_data, a:buffer, {}), 'cwd', v:null)
   20              0.000006     endif
                            
   20   0.056203   0.000258     let [l:temporary_file, l:command, l:file_created] = ale#command#FormatCommand(   a:buffer,   get(l:options, 'executable', ''),   a:command,   get(l:options, 'read_buffer', 0),   get(l:options, 'input', v:null),   l:cwd,   get(l:options, 'filename_mappings', []),)
   20   0.001222   0.000239     let l:command = ale#job#PrepareCommand(a:buffer, l:command)
   20              0.000201     let l:job_options = {   'exit_cb': {job_id, exit_code -> s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )},   'mode': 'nl',}
                            
   20              0.000029     if l:output_stream is# 'stdout'
                                    let l:job_options.out_cb = function('s:GatherOutput', [l:line_list])
   20              0.000024     elseif l:output_stream is# 'stderr'
                                    let l:job_options.err_cb = function('s:GatherOutput', [l:line_list])
   20              0.000016     elseif l:output_stream is# 'both'
   20              0.000099         let l:job_options.out_cb = function('s:GatherOutput', [l:line_list])
   20              0.000061         let l:job_options.err_cb = function('s:GatherOutput', [l:line_list])
   20              0.000008     endif
                            
   20              0.000020     let l:status = 'failed'
                            
   20              0.000039     if get(g:, 'ale_run_synchronously') == 1
                                    if get(g:, 'ale_emulate_job_failure') == 1
                                        let l:job_id = 0
                                    else
                                        " Generate a fake job ID for tests.
                                        let s:fake_job_id = get(s:, 'fake_job_id', 0) + 1
                                        let l:job_id = s:fake_job_id
                                    endif
   20              0.000046     elseif has('win32')
                                    let l:job_id = ale#job#StartWithCmd(l:command, l:job_options)
   20              0.000007     else
   20   0.012533   0.000180         let l:job_id = ale#job#Start(l:command, l:job_options)
   20              0.000008     endif
                            
   20              0.000012     if l:job_id
   20              0.000023         let l:status = 'started'
   20              0.000066         let l:job_type = getbufvar(a:buffer, 'ale_job_type', 'all')
                            
   20   0.000288   0.000192         call ale#command#InitData(a:buffer)
   20              0.000051         let s:buffer_data[a:buffer].jobs[l:job_id] = l:job_type
   20              0.000006     endif
                            
   20              0.000018     if g:ale_history_enabled
   20   0.000650   0.000136         call ale#history#Add(a:buffer, l:status, l:job_id, l:command)
   20              0.000006     endif
                            
   20              0.000013     if !l:job_id
                                    return 0
   20              0.000006     endif
                            
                                " We'll return this Dictionary. A `result_callback` can be assigned to it
                                " later for capturing the result of a:Callback.
                                "
                                " The `_deferred_job_id` is used for both checking the type of object, and
                                " for checking the job ID and status.
                                "
                                " The cwd is kept and used as the default value for the next command in
                                " the chain.
                                "
                                " The original command here is used in tests.
   20              0.000099     let l:result = {   '_deferred_job_id': l:job_id,   'executable': get(l:options, 'executable', ''),   'cwd': l:cwd,   'command': a:command,}
                            
   20              0.000037     if get(g:, 'ale_run_synchronously') == 1 && l:job_id
                                    if !exists('g:ale_run_synchronously_callbacks')
                                        let g:ale_run_synchronously_callbacks = []
                                    endif
                            
                                    if get(g:, 'ale_run_synchronously_emulate_commands', 0)
                                        call add(   g:ale_run_synchronously_callbacks,   {exit_code, output -> [       extend(l:line_list, output),       l:job_options.exit_cb(l:job_id, exit_code),   ]})
                                    else
                                        " Run a command synchronously if this test option is set.
                                        call extend(l:line_list, systemlist(   type(l:command) is v:t_list       ? join(l:command[0:1]) . ' ' . ale#Escape(l:command[2])       : l:command))
                            
                                        " Don't capture output when the callbacks aren't set.
                                        if !has_key(l:job_options, 'out_cb')&& !has_key(l:job_options, 'err_cb')
                                            let l:line_list = []
                                        endif
                            
                                        call add(   g:ale_run_synchronously_callbacks,   {-> l:job_options.exit_cb(l:job_id, v:shell_error)})
                                    endif
   20              0.000006     endif
                            
   20              0.000037     return l:result

FUNCTION  ale#handlers#eslint#GetCwd()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/handlers/eslint.vim line 43
Called 20 times
Total time:   0.807859
 Self time:   0.000570

count  total (s)   self (s)
                                " ESLint 6 loads plugins/configs/parsers from the project root
                                " By default, the project root is simply the CWD of the running process.
                                " https://github.com/eslint/rfcs/blob/master/designs/2018-simplified-package-loading/README.md
                                " https://github.com/dense-analysis/ale/issues/2787
                                "
                                " If eslint is installed in a directory which contains the buffer, assume
                                " it is the ESLint project root.  Otherwise, use nearest node_modules.
                                " Note: If node_modules not present yet, can't load local deps anyway.
   20   0.807446   0.000157     let l:executable = ale#node#FindNearestExecutable(a:buffer, s:executables)
                            
   20              0.000045     if !empty(l:executable)
   20              0.000070         let l:nmi = strridx(l:executable, 'node_modules')
   20              0.000055         let l:project_dir = l:executable[0:l:nmi - 2]
                                else
                                    let l:modules_dir = ale#path#FindNearestDirectory(a:buffer, 'node_modules')
                                    let l:project_dir = !empty(l:modules_dir) ? fnamemodify(l:modules_dir, ':h:h') : ''
   20              0.000010     endif
                            
   20              0.000040     return !empty(l:project_dir) ? l:project_dir : ''

FUNCTION  ale#events#ClockMilliseconds()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/events.vim line 10
Called 3 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    3              0.000014     return float2nr(reltimefloat(reltime()) * 1000)

FUNCTION  ale#command#IsDeferred()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/command.vim line 471
Called 140 times
Total time:   0.000548
 Self time:   0.000548

count  total (s)   self (s)
  140              0.000506     return type(a:value) is v:t_dict && has_key(a:value, '_deferred_job_id')

FUNCTION  syntastic#log#debugShowVariables()
    Defined: ~/.config/nvim/plugged/syntastic/autoload/syntastic/log.vim line 103
Called 7 times
Total time:   0.000076
 Self time:   0.000058

count  total (s)   self (s)
    7   0.000067   0.000049     if !s:_isDebugEnabled(a:level)
    7              0.000004         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = type(a:names) == type('') ? [a:names] : a:names
                                for name in vlist
                                    let msg = s:_format_variable(name)
                                    if msg !=# ''
                                        echomsg leader . msg
                                    endif
                                endfor
                            
                                call s:_logRedirect(0)

FUNCTION  90()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/registry.vim line 360
Called 3 times
Total time:   0.000138
 Self time:   0.000051

count  total (s)   self (s)
    3   0.000137   0.000050     return filter( map(copy(a:cnames), 'self._findChecker(v:val)'), '!empty(v:val)' )

FUNCTION  91()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/registry.vim line 364
Called 3 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    3              0.000009     if !a:force && has_key(self._checkerMap, a:filetype)
    3              0.000002         return
                                endif
                            
                                execute 'runtime! syntax_checkers/' . a:filetype . '/*.vim'
                            
                                if !has_key(self._checkerMap, a:filetype)
                                    let self._checkerMap[a:filetype] = {}
                                endif

FUNCTION  92()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/registry.vim line 377
Called 3 times
Total time:   0.000068
 Self time:   0.000068

count  total (s)   self (s)
    3              0.000024     if exists('g:syntastic_' . a:filetype . '_checkers') && type(g:syntastic_{a:filetype}_checkers) != type([])
                            
                                    unlet! g:syntastic_{a:filetype}_checkers
                                    call syntastic#log#error('variable g:syntastic_' . a:filetype . '_checkers has to be a list of strings')
    3              0.000001     endif
                            
    3              0.000014     if exists('g:syntastic_' . a:filetype . '_checker') && !exists('g:syntastic_' . a:filetype . '_checkers') && type(g:syntastic_{a:filetype}_checker) == type('')
                            
                                    let g:syntastic_{a:filetype}_checkers = [g:syntastic_{a:filetype}_checker]
                                    call syntastic#log#oneTimeWarn('variable g:syntastic_' . a:filetype . '_checker is deprecated')
    3              0.000001     endif

FUNCTION  94()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/signs.vim line 27
Called 6 times
Total time:   0.000111
 Self time:   0.000050

count  total (s)   self (s)
    6   0.000109   0.000048     return has('signs') && syntastic#util#var('enable_signs')

FUNCTION  97()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/signs.vim line 86
Called 3 times
Total time:   0.000088
 Self time:   0.000074

count  total (s)   self (s)
    3              0.000003     let loclist = a:loclist
    3   0.000021   0.000007     if !loclist.isEmpty()
                            
                                    let buf = bufnr('')
                                    if !bufloaded(buf)
                                        " signs can be placed only in loaded buffers
                                        return
                                    endif
                            
                                    " errors come first, so that they are not masked by warnings
                                    let issues = copy(loclist.errors())
                                    call extend(issues, loclist.warnings())
                                    call filter(issues, 'v:val["bufnr"] == buf')
                                    let seen = {}
                            
                                    for i in issues
                                        if i['lnum'] > 0 && !has_key(seen, i['lnum'])
                                            let seen[i['lnum']] = 1
                            
                                            let sign_severity = i['type'] ==? 'W' ? 'Warning' : 'Error'
                                            let sign_subtype = get(i, 'subtype', '')
                                            let sign_type = 'Syntastic' . sign_subtype . sign_severity
                            
                                            execute 'sign place ' . s:next_sign_id . ' line=' . i['lnum'] . ' name=' . sign_type . ' buffer=' . i['bufnr']
                                            call add(self._bufSignIds(), s:next_sign_id)
                                            let s:next_sign_id += 1
                                        endif
                                    endfor
    3              0.000001     endif

FUNCTION  98()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/signs.vim line 119
Called 3 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    3              0.000005     if has('signs')
    3              0.000007         for s in reverse(copy(a:ids))
                                        execute 'sign unplace ' . s
                                        call remove(self._bufSignIds(), index(self._bufSignIds(), s))
    3              0.000002         endfor
    3              0.000001     endif

FUNCTION  99()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/signs.vim line 129
Called 3 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    3              0.000005     if !exists('b:syntastic_private_sign_ids')
                                    let b:syntastic_private_sign_ids = []
    3              0.000001     endif
    3              0.000003     return b:syntastic_private_sign_ids

FUNCTION  <SNR>259_PriorityCmd()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/sign.vim line 156
Called 3 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    3              0.000002     if s:supports_sign_groups
    3              0.000005         return ' priority=' . g:ale_sign_priority . ' '
                                else
                                    return ''
                                endif

FUNCTION  <SNR>40__is_quitting()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic.vim line 715
Called 7 times
Total time:   0.000083
 Self time:   0.000083

count  total (s)   self (s)
    7              0.000007     let quitting = 0
    7              0.000015     if exists('w:syntastic_wid')
    1              0.000004         let key = a:buf . '_' . getbufvar(a:buf, 'changetick') . '_' . w:syntastic_wid
    1              0.000003         let idx = index(s:_quit_pre, key)
    1              0.000001         if idx >= 0
    1              0.000002             call remove(s:_quit_pre, idx)
    1              0.000001             let quitting = 1
    1              0.000000         endif
    7              0.000003     endif
                            
    7              0.000005     return quitting

FUNCTION  syntastic#util#getbufvar()
    Defined: ~/.config/nvim/plugged/syntastic/autoload/syntastic/util.vim line 126
Called 210 times
Total time:   0.001599
 Self time:   0.001599

count  total (s)   self (s)
  210              0.001448     return a:0 ? s:_getbufvar(a:buf, a:name, a:1) : getbufvar(a:buf, a:name)

FUNCTION  syntastic#util#setWids()
    Defined: ~/.config/nvim/plugged/syntastic/autoload/syntastic/util.vim line 416
Called 1 time
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    2              0.000005     for tab in range(1, tabpagenr('$'))
    2              0.000004         for win in range(1, tabpagewinnr(tab, '$'))
    1              0.000003             if gettabwinvar(tab, win, 'syntastic_wid') ==# ''
    1              0.000004                 call settabwinvar(tab, win, 'syntastic_wid', s:_wid_base . s:_wid_pool)
    1              0.000002                 let s:_wid_pool += 1
    1              0.000000             endif
    2              0.000001         endfor
    2              0.000001     endfor

FUNCTION  coc#_cancel()
    Defined: ~/.config/nvim/plugged/coc.nvim/autoload/coc.vim line 95
Called 2 times
Total time:   0.000159
 Self time:   0.000038

count  total (s)   self (s)
                              " hack for close pum
    2              0.000003   if pumvisible()
    1              0.000010     let g:coc#_context = {'start': 0, 'preselect': -1,'candidates': []}
    1              0.000008     call feedkeys("\<Plug>CocRefresh", 'i')
    1   0.000130   0.000009     call coc#rpc#notify('stopCompletion', [])
    2              0.000001   endif

FUNCTION  <SNR>217_CheckForBadConfig()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/handlers/eslint.vim line 86
Called 1 time
Total time:   0.000500
 Self time:   0.000500

count  total (s)   self (s)
    1              0.000004     let l:config_error_pattern = '\v^ESLint couldn''t find a configuration file'   . '|^Cannot read config file'   . '|^.*Configuration for rule .* is invalid'   . '|^ImportDeclaration should appear'
                            
                                " Look for a message in the first few lines which indicates that
                                " a configuration file couldn't be found.
    2              0.000004     for l:line in a:lines[:10]
    1              0.000474         let l:match = matchlist(l:line, l:config_error_pattern)
                            
    1              0.000003         if len(l:match) > 0
                                        " Don't show the missing config error if we've disabled it.
                                        if ale#Var(a:buffer, 'javascript_eslint_suppress_missing_config')&& l:match[0] is# 'ESLint couldn''t find a configuration file'
                                            return 0
                                        endif
                            
                                        return 1
    1              0.000001         endif
    2              0.000002     endfor
                            
    1              0.000001     return 0

FUNCTION  syntastic#util#isRunningWindows()
    Defined: ~/.config/nvim/plugged/syntastic/autoload/syntastic/util.vim line 11
Called 3 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    3              0.000030     return has('win16') || has('win32') || has('win64')

FUNCTION  <SNR>211_GetLintFileValues()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/engine.vim line 607
Called 20 times
Total time:   3.668603
 Self time:   0.001721

count  total (s)   self (s)
   20              0.000032     let l:deferred_list = []
   20              0.000021     let l:new_slots = []
                            
   60              0.000087     for [l:lint_file, l:linter] in a:slots
   40   0.000467   0.000309         while ale#command#IsDeferred(l:lint_file) && has_key(l:lint_file, 'value')
                                        " If we've already computed the return value, use it.
                                        let l:lint_file = l:lint_file.value
   40              0.000025         endwhile
                            
   40   0.000376   0.000268         if ale#command#IsDeferred(l:lint_file)
                                        " If we are going to return the result later, wait for it.
                                        call add(l:deferred_list, l:lint_file)
   40              0.000020         else
                                        " If we have the value now, coerce it to 0 or 1.
   40              0.000058             let l:lint_file = l:lint_file is 1
   40              0.000016         endif
                            
   40              0.000100         call add(l:new_slots, [l:lint_file, l:linter])
   60              0.000048     endfor
                            
   20              0.000032     if !empty(l:deferred_list)
                                    for l:deferred in l:deferred_list
                                        let l:deferred.result_callback =   {-> s:GetLintFileValues(l:new_slots, a:Callback)}
                                    endfor
   20              0.000010     else
   20   3.666739   0.000123         call a:Callback(l:new_slots)
   20              0.000022     endif

FUNCTION  <SNR>71_GetVars()
    Defined: ~/.config/nvim/plugged/vim-polyglot/indent/javascript.vim line 49
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000011   call extend(b:,extend(s:bvars,{'js_cache': [0,0,0]}),'keep')

FUNCTION  <SNR>216_FindHistoryItem()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/history.vim line 36
Called 2 times
Total time:   0.000041
 Self time:   0.000030

count  total (s)   self (s)
                                " Search backwards to find a matching job ID. IDs might be recycled,
                                " so finding the last one should be good enough.
    2   0.000023   0.000012     for l:obj in reverse(ale#history#Get(a:buffer))
    2              0.000003         if l:obj.job_id == a:job_id
    2              0.000002             return l:obj
                                    endif
                                endfor
                            
                                return {}

FUNCTION  <SNR>212_GatherOutput()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/command.vim line 281
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003     call add(a:line_list, a:line)

FUNCTION  ale#Queue()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale.vim line 123
Called 21 times
Total time:   3.495886
 Self time:   0.001035

count  total (s)   self (s)
   21              0.000031     if a:0 > 2
                                    throw 'too many arguments!'
   21              0.000010     endif
                            
   21              0.000063     let l:buffer = get(a:000, 1, v:null)
                            
   21              0.000036     if l:buffer is v:null
   18              0.000038         let l:buffer = bufnr('')
   21              0.000011     endif
                            
   21              0.000045     if type(l:buffer) isnot v:t_number
                                    throw 'buffer_number must be a Number'
   21              0.000008     endif
                            
   21   0.002263   0.000137     if ale#ShouldDoNothing(l:buffer)
                                    return
   21              0.000018     endif
                            
                                " Default linting_flag to ''
   21              0.000060     let l:should_lint_file = get(a:000, 0) is# 'lint_file'
                            
   21              0.000027     if s:lint_timer != -1
    2              0.000007         call timer_stop(s:lint_timer)
    2              0.000003         let s:lint_timer = -1
   21              0.000009     endif
                            
   21              0.000019     if a:delay > 0
    2              0.000014         let s:lint_timer = timer_start(   a:delay,   function('s:Lint', [l:buffer, l:should_lint_file]))
   19              0.000010     else
   19   3.492908   0.000183         call s:Lint(l:buffer, l:should_lint_file, 0)
   21              0.000007     endif

FUNCTION  <SNR>262_AddSubCallbacks()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/fix.vim line 238
Called 6 times
Total time:   0.000070
 Self time:   0.000070

count  total (s)   self (s)
    6              0.000018     if type(a:callbacks) is v:t_string
                                    call add(a:full_list, a:callbacks)
    6              0.000012     elseif type(a:callbacks) is v:t_list
                                    call extend(a:full_list, a:callbacks)
    6              0.000003     else
    6              0.000006         return 0
                                endif
                            
                                return 1

FUNCTION  syntastic#util#var()
    Defined: ~/.config/nvim/plugged/syntastic/autoload/syntastic/util.vim line 170
Called 43 times
Total time:   0.000551
 Self time:   0.000373

count  total (s)   self (s)
   43   0.000541   0.000362     return call('syntastic#util#rawVar', ['syntastic_' . a:name] + a:000)

FUNCTION  syntastic#util#compareLexi()
    Defined: ~/.config/nvim/plugged/syntastic/autoload/syntastic/util.vim line 191
Called 3 times
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    3              0.000013     for idx in range(max([len(a:a), len(a:b)]))
    3              0.000007         let a_element = str2nr(get(a:a, idx, 0))
    3              0.000006         let b_element = str2nr(get(a:b, idx, 0))
    3              0.000003         if a_element != b_element
    3              0.000003             return a_element > b_element ? 1 : -1
                                    endif
                                endfor
                                " still here, thus everything matched
                                return 0

FUNCTION  ale#engine#IsExecutable()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/engine.vim line 53
Called 40 times
Total time:   0.335329
 Self time:   0.334726

count  total (s)   self (s)
   40              0.000057     if empty(a:executable)
                                    " Don't log the executable check if the executable string is empty.
                                    return 0
   40              0.000014     endif
                            
                                " Check for a cached executable() check.
   40              0.000143     let l:result = get(s:executable_cache_map, a:executable, v:null)
                            
   40              0.000054     if l:result isnot v:null
   20              0.000015         return l:result
   20              0.000006     endif
                            
                                " Check if the file is executable, and convert -1 to 1.
   20              0.333674     let l:result = executable(a:executable) isnot 0
                            
                                " Cache the executable check if we found it, or if the option to cache
                                " failing checks is on.
   20              0.000124     if l:result || get(g:, 'ale_cache_executable_check_failures', 0)
                                    let s:executable_cache_map[a:executable] = l:result
   20              0.000017     endif
                            
   20              0.000023     if g:ale_history_enabled
   20   0.000908   0.000305         call ale#history#Add(a:buffer, l:result, 'executable', a:executable)
   20              0.000008     endif
                            
   20              0.000021     return l:result

FUNCTION  ale#Escape()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale.vim line 219
Called 80 times
Total time:   0.000883
 Self time:   0.000883

count  total (s)   self (s)
   80              0.000268     if fnamemodify(&shell, ':t') is? 'cmd.exe'
                                    " If the string contains spaces, it will be surrounded by quotes.
                                    " Otherwise, special characters will be escaped with carets (^).
                                    return substitute(   a:str =~# ' '       ?  '"' .  substitute(a:str, '"', '""', 'g') . '"'       : substitute(a:str, '\v([&|<>^])', '^\1', 'g'),   '%',   '%%',   'g',)
   80              0.000032     endif
                            
   80              0.000211     return shellescape (a:str)

FUNCTION  <SNR>20_request()
    Defined: ~/.config/nvim/plugged/coc.nvim/autoload/coc/client.vim line 153
Called 4 times
Total time:   0.007403
 Self time:   0.007385

count  total (s)   self (s)
    4   0.000042   0.000024   let channel = coc#client#get_channel(self)
    4              0.000008   if empty(channel) | return '' | endif
    4              0.000003   try
    4              0.000003     if s:is_vim
                                  let res = ch_evalexpr(channel, [a:method, a:args], {'timeout': 60 * 1000})
                                  if type(res) == 1 && res ==# ''
                                    throw 'request '.a:method. ' '.string(a:args).' timeout after 60s'
                                  endif
                                  let [l:errmsg, res] =  res
                                  if !empty(l:errmsg)
                                    throw l:errmsg
                                  else
                                    return res
                                  endif
    4              0.000002     else
    4              0.007200       return call('rpcrequest', [channel, a:method] + a:args)
                                endif
                              catch /.*/
                                if v:exception =~# 'E475'
                                  if get(g:, 'coc_vim_leaving', 0) | return | endif
                                  echohl Error | echom '['.self.name.'] server connection lost' | echohl None
                                  let name = self.name
                                  call s:on_exit(name, 0)
                                  execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
                                elseif v:exception =~# 'E12'
                                  " neovim's bug, ignore it
                                else
                                  echohl Error | echo 'Error on request ('.a:method.'): '.v:exception | echohl None
                                endif
    4              0.000004   endtry

FUNCTION  <SNR>260_FixList()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/list.vim line 60
Called 1 time
Total time:   0.001030
 Self time:   0.000293

count  total (s)   self (s)
    1   0.000015   0.000005     let l:format = ale#Var(a:buffer, 'loclist_msg_format')
    1              0.000001     let l:new_list = []
                            
   22              0.000014     for l:item in a:list
   21              0.000053         let l:fixed_item = copy(l:item)
                            
   21   0.000839   0.000112         let l:fixed_item.text = ale#GetLocItemMessage(l:item, l:format)
                            
   21              0.000016         if l:item.bufnr == -1
                                        " If the buffer number is invalid, remove it.
                                        call remove(l:fixed_item, 'bufnr')
   21              0.000006         endif
                            
   21              0.000031         call add(l:new_list, l:fixed_item)
   22              0.000009     endfor
                            
    1              0.000001     return l:new_list

FUNCTION  coc#rpc#ready()
    Defined: ~/.config/nvim/plugged/coc.nvim/autoload/coc/rpc.vim line 31
Called 117 times
Total time:   0.001059
 Self time:   0.001059

count  total (s)   self (s)
  117              0.000622   if empty(s:client) || s:client['running'] == 0
                                return 0
  117              0.000058   endif
  117              0.000110   return 1

FUNCTION  ale#highlight#nvim_buf_clear_namespace()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/highlight.vim line 44
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000010     call nvim_buf_clear_namespace(a:buffer, a:ns_id, a:line_start, a:line_end)

FUNCTION  ale#linter#GetCommand()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/linter.vim line 439
Called 20 times
Total time:   0.812595
 Self time:   0.000229

count  total (s)   self (s)
   20              0.000055     let l:Command = a:linter.command
                            
   20   0.812525   0.000159     return type(l:Command) is v:t_func ? l:Command(a:buffer) : l:Command

FUNCTION  <SNR>253_syntax_at()
    Defined: ~/.config/nvim/plugged/vim-polyglot/autoload/jsx_pretty/indent.vim line 30
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000003   return synIDattr(synID(a:lnum, a:col, 1), 'name')

FUNCTION  ale_linters#vue#vls#GetProjectRoot()
    Defined: ~/.config/nvim/plugged/ale/ale_linters/vue/vls.vim line 7
Called 20 times
Total time:   0.377785
 Self time:   0.000439

count  total (s)   self (s)
   20   0.377636   0.000290     let l:package_path = ale#path#FindNearestFile(a:buffer, 'package.json')
                            
   20              0.000116     return !empty(l:package_path) ? fnamemodify(l:package_path, ':h') : ''

FUNCTION  <SNR>211_RunLinters()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/engine.vim line 644
Called 20 times
Total time:   3.666365
 Self time:   0.002041

count  total (s)   self (s)
   20   0.002953   0.000184     call s:StopCurrentJobs(a:buffer, a:should_lint_file, a:slots)
   20   0.002357   0.000298     call s:RemoveProblemsForDisabledLinters(a:buffer, a:linters)
                            
                                " We can only clear the results if we aren't checking the buffer.
   20   0.000556   0.000298     let l:can_clear_results = !ale#engine#IsCheckingBuffer(a:buffer)
                            
   20   0.000163   0.000145     silent doautocmd <nomodeline> User ALELintPre
                            
   60              0.000111     for [l:lint_file, l:linter] in a:slots
                                    " Only run lint_file linters if we should.
   40              0.000055         if !l:lint_file || a:should_lint_file
   40   3.659589   0.000370             if s:RunLinter(a:buffer, l:linter, l:lint_file)
                                            " If a single linter ran, we shouldn't clear everything.
   20              0.000027                 let l:can_clear_results = 0
   40              0.000018             endif
                                    else
                                        " If we skipped running a lint_file linter still in the list,
                                        " we shouldn't clear everything.
                                        let l:can_clear_results = 0
   40              0.000014         endif
   60              0.000045     endfor
                            
                                " Clear the results if we can. This needs to be done when linters are
                                " disabled, or ALE itself is disabled.
   20              0.000015     if l:can_clear_results
                                    call ale#engine#SetResults(a:buffer, [])
   20              0.000016     elseif a:new_buffer
                                    call s:AddProblemsFromOtherBuffers(   a:buffer,   map(copy(a:slots), 'v:val[1]'))
   20              0.000020     endif

FUNCTION  SyntasticLoclistHide()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/loclist.vim line 347
Called 3 times
Total time:   0.000047
 Self time:   0.000026

count  total (s)   self (s)
    3   0.000042   0.000021     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: hide')
    3              0.000004     silent! lclose

FUNCTION  ale#util#BinarySearch()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/util.vim line 231
Called 33 times
Total time:   0.003341
 Self time:   0.003341

count  total (s)   self (s)
   33              0.000048     let l:min = 0
   33              0.000091     let l:max = len(a:loclist) - 1
                            
   53              0.000077     while 1
   53              0.000102         if l:max < l:min
    5              0.000010             return -1
   48              0.000033         endif
                            
   48              0.000138         let l:mid = (l:min + l:max) / 2
   48              0.000146         let l:item = a:loclist[l:mid]
                            
                                    " Binary search for equal buffers, equal lines, then near columns.
   48              0.000133         if l:item.bufnr < a:buffer
                                        let l:min = l:mid + 1
   48              0.000096         elseif l:item.bufnr > a:buffer
                                        let l:max = l:mid - 1
   48              0.000096         elseif l:item.lnum < a:line
    5              0.000016             let l:min = l:mid + 1
   43              0.000067         elseif l:item.lnum > a:line
   15              0.000040             let l:max = l:mid - 1
   28              0.000012         else
                                        " This part is a small sequential search.
   28              0.000033             let l:index = l:mid
                            
                                        " Search backwards to find the first problem on the line.
   28              0.000116             while l:index > 0&& a:loclist[l:index - 1].bufnr == a:buffer&& a:loclist[l:index - 1].lnum == a:line
                                            let l:index -= 1
   28              0.000021             endwhile
                            
                                        " Find the last problem on or before this column.
   28              0.000134             while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col <= a:column
                                            let l:index += 1
   28              0.000012             endwhile
                            
                                        " Scan forwards to find the last item on the column for the item
                                        " we found, which will have the most serious problem.
   28              0.000060             let l:item_column = a:loclist[l:index].col
                            
   28              0.000113             while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col == l:item_column
                                            let l:index += 1
   28              0.000019             endwhile
                            
   28              0.000028             return l:index
   20              0.000019         endif
   20              0.000026     endwhile

FUNCTION  ale#events#SaveEvent()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/events.vim line 25
Called 4 times
Total time:   0.572194
 Self time:   0.000374

count  total (s)   self (s)
    4   0.000110   0.000045     let l:should_lint = ale#Var(a:buffer, 'enabled') && g:ale_lint_on_save
                            
    4              0.000005     if l:should_lint
    4              0.000016         call setbufvar(a:buffer, 'ale_save_event_fired', 1)
    4              0.000003     endif
                            
    4   0.000141   0.000058     if ale#Var(a:buffer, 'fix_on_save') && !ale#events#QuitRecently(a:buffer)
    3   0.001215   0.000153         let l:will_fix = ale#fix#Fix(a:buffer, 'save_file')
    3              0.000007         let l:should_lint = l:should_lint && !l:will_fix
    4              0.000002     endif
                            
    4   0.000070   0.000039     if l:should_lint && !ale#events#QuitRecently(a:buffer)
    3   0.570603   0.000025         call ale#Queue(0, 'lint_file', a:buffer)
    4              0.000001     endif

FUNCTION  UltiSnips#TrackChange()
    Defined: ~/.config/nvim/plugged/ultisnips/autoload/UltiSnips.vim line 166
Called 11 times
Total time:   0.031678
 Self time:   0.031678

count  total (s)   self (s)
   11              0.031655     py3 UltiSnips_Manager._track_change()

FUNCTION  <SNR>71_sw()
    Defined: ~/.config/nvim/plugged/vim-polyglot/indent/javascript.vim line 55
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000001     return shiftwidth()

FUNCTION  syntastic#util#bufIsActive()
    Defined: ~/.config/nvim/plugged/syntastic/autoload/syntastic/util.vim line 238
Called 3 times
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
                                " convert to number, or hell breaks loose
    3              0.000006     let buf = str2nr(a:buffer)
                            
    3              0.000006     if !bufloaded(buf) || !buflisted(buf)
                                    return 0
    3              0.000001     endif
                            
                                " get rid of hidden buffers
    3              0.000009     for tab in range(1, tabpagenr('$'))
    3              0.000008         if index(tabpagebuflist(tab), buf) >= 0
    3              0.000002             return 1
                                    endif
                                endfor
                            
                                return 0

FUNCTION  ale#cursor#TruncatedEcho()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/cursor.vim line 13
Called 28 times
Total time:   0.006324
 Self time:   0.006229

count  total (s)   self (s)
   28              0.000048     let l:message = a:original_message
                                " Change tabs to spaces.
   28              0.000105     let l:message = substitute(l:message, "\t", ' ', 'g')
                                " Remove any newlines in the message.
   28              0.000068     let l:message = substitute(l:message, "\n", '', 'g')
                            
                                " We need to remember the setting for shortmess and reset it again.
   28              0.000065     let l:shortmess_options = &l:shortmess
                            
   28              0.000019     try
   28              0.000061         let l:cursor_position = getpos('.')
                            
                                    " The message is truncated and saved to the history.
   28   0.000201   0.000181         silent! setlocal shortmess+=T
                            
   28              0.000017         try
   28              0.004757             exec "norm! :echomsg l:message\n"
                                    catch /^Vim\%((\a\+)\)\=:E523/
                                        " Fallback into manual truncate (#1987)
                                        let l:winwidth = winwidth(0)
                            
                                        if l:winwidth < strdisplaywidth(l:message)
                                            " Truncate message longer than window width with trailing '...'
                                            let l:message = l:message[:l:winwidth - 4] . '...'
                                        endif
                            
                                        exec 'echomsg l:message'
                                    catch /E481/
                                        " Do nothing if running from a visual selection.
   28              0.000020         endtry
                            
                                    " Reset the cursor position if we moved off the end of the line.
                                    " Using :norm and :echomsg can move the cursor off the end of the
                                    " line.
   28              0.000112         if l:cursor_position != getpos('.')
                                        call setpos('.', l:cursor_position)
   28              0.000014         endif
   28              0.000029     finally
   28   0.000207   0.000132         let &l:shortmess = l:shortmess_options
   28              0.000025     endtry

FUNCTION  ale#util#GetItemPriority()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/util.vim line 128
Called 21 times
Total time:   0.000147
 Self time:   0.000147

count  total (s)   self (s)
   21              0.000018     if a:item.type is# 'I'
                                    return g:ale#util#info_priority
   21              0.000006     endif
                            
   21              0.000015     if a:item.type is# 'W'
   21              0.000029         if get(a:item, 'sub_type', '') is# 'style'
                                        return g:ale#util#style_warning_priority
   21              0.000014         endif
                            
   21              0.000015         return g:ale#util#warning_priority
                                endif
                            
                                if get(a:item, 'sub_type', '') is# 'style'
                                    return g:ale#util#style_error_priority
                                endif
                            
                                return g:ale#util#error_priority

FUNCTION  ale#engine#RunLinters()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/engine.vim line 679
Called 20 times
Total time:   3.670155
 Self time:   0.000676

count  total (s)   self (s)
                                " Initialise the buffer information if needed.
   20   0.000341   0.000144     let l:new_buffer = ale#engine#InitBufferInfo(a:buffer)
                            
   20   3.669771   0.000489     call s:GetLintFileValues(   s:GetLintFileSlots(a:buffer, a:linters),   {       slots -> s:RunLinters(           a:buffer,           a:linters,           slots,           a:should_lint_file,           l:new_buffer,       )   })

FUNCTION  <SNR>42_getline()
    Defined: ~/.config/nvim/plugged/auto-pairs/plugin/auto-pairs.vim line 139
Called 2 times
Total time:   0.000087
 Self time:   0.000087

count  total (s)   self (s)
    2              0.000012   let line = getline('.')
    2              0.000005   let pos = col('.') - 1
    2              0.000005   let before = strpart(line, 0, pos)
    2              0.000005   let after = strpart(line, pos)
    2              0.000003   let afterline = after
    2              0.000002   if g:AutoPairsMultilineClose
    2              0.000004     let n = line('$')
    2              0.000002     let i = line('.')+1
    2              0.000004     while i <= n
    2              0.000004       let line = getline(i)
    2              0.000003       let after = after.' '.line
    2              0.000017       if !(line =~ '\v^\s*$')
    2              0.000002         break
                                  end
                                  let i = i+1
    2              0.000002     endwhile
    2              0.000001   end
    2              0.000005   return [before, after, afterline]

FUNCTION  <SNR>71_SynAt()
    Defined: ~/.config/nvim/plugged/vim-polyglot/indent/javascript.vim line 84
Called 3 times
Total time:   0.007593
 Self time:   0.007593

count  total (s)   self (s)
    3              0.000007   let byte = line2byte(a:l) + a:c - 1
    3              0.000008   let pos = index(s:synid_cache[0], byte)
    3              0.000002   if pos == -1
    3              0.007563     let s:synid_cache[:] += [[byte], [synIDattr(synID(a:l, a:c, 0), 'name')]]
    3              0.000003   endif
    3              0.000006   return s:synid_cache[1][pos]

FUNCTION  ale#lsp_linter#FindProjectRoot()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/lsp_linter.vim line 203
Called 20 times
Total time:   0.378904
 Self time:   0.001119

count  total (s)   self (s)
   20              0.000114     let l:buffer_ale_root = getbufvar(   a:buffer,   'ale_root',   getbufvar(a:buffer, 'ale_lsp_root', {}))
                            
   20              0.000043     if type(l:buffer_ale_root) is v:t_string
                                    return l:buffer_ale_root
   20              0.000010     endif
                            
                                " Try to get a buffer-local setting for the root
   20              0.000042     if has_key(l:buffer_ale_root, a:linter.name)
                                    let l:Root = l:buffer_ale_root[a:linter.name]
                            
                                    if type(l:Root) is v:t_func
                                        return l:Root(a:buffer)
                                    else
                                        return l:Root
                                    endif
   20              0.000010     endif
                            
   20              0.000034     let l:global_root = g:ale_root
                            
   20              0.000078     if empty(g:ale_root) && exists('g:ale_lsp_root')
                                    let l:global_root = g:ale_lsp_root
   20              0.000007     endif
                            
                                " Try to get a global setting for the root
   20              0.000050     if has_key(l:global_root, a:linter.name)
                                    let l:Root = l:global_root[a:linter.name]
                            
                                    if type(l:Root) is v:t_func
                                        return l:Root(a:buffer)
                                    else
                                        return l:Root
                                    endif
   20              0.000006     endif
                            
                                " Fall back to the linter-specific configuration
   20              0.000032     if has_key(a:linter, 'project_root')
   20              0.000054         let l:Root = a:linter.project_root
                            
   20   0.378020   0.000235         return type(l:Root) is v:t_func ? l:Root(a:buffer) : l:Root
                                endif
                            
                                return ale#util#GetFunction(a:linter.project_root_callback)(a:buffer)

FUNCTION  ale#util#FindItemAtCursor()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/util.vim line 484
Called 33 times
Total time:   0.004359
 Self time:   0.001018

count  total (s)   self (s)
   33              0.000168     let l:info = get(g:ale_buffer_info, a:buffer, {})
   33              0.000113     let l:loclist = get(l:info, 'loclist', [])
   33              0.000117     let l:pos = getpos('.')
   33   0.003727   0.000386     let l:index = ale#util#BinarySearch(l:loclist, a:buffer, l:pos[1], l:pos[2])
   33              0.000102     let l:loc = l:index >= 0 ? l:loclist[l:index] : {}
                            
   33              0.000069     return [l:info, l:loc]

FUNCTION  TrimWhiteSpace()
    Defined: ~/.config/nvim/init.vim line 83
Called 4 times
Total time:   0.000457
 Self time:   0.000457

count  total (s)   self (s)
    4              0.000031 	let l:save = winsaveview()
    4              0.000400 	keeppatterns %s/\s\+$//e
    4              0.000020 	call winrestview(l:save)

FUNCTION  ale#command#CdString()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/command.vim line 173
Called 20 times
Total time:   0.000699
 Self time:   0.000500

count  total (s)   self (s)
   20              0.000195     let l:match = matchstrpos(a:directory, s:path_format_regex)
                                " Do not escape the directory here if it's a valid format string.
                                " This allows us to use sequences like %s:h, %s:h:h, etc.
   20   0.000365   0.000166     let l:directory = l:match[1:] == [0, len(a:directory)]   ? a:directory   : ale#Escape(a:directory)
                            
   20              0.000052     if has('win32')
                                    return 'cd /d ' . l:directory . ' && '
   20              0.000006     endif
                            
   20              0.000029     return 'cd ' . l:directory . ' && '

FUNCTION  <SNR>259_UpdateLineNumbers()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/sign.vim line 259
Called 1 time
Total time:   0.000179
 Self time:   0.000179

count  total (s)   self (s)
    1              0.000001     let l:line_map = {}
    1              0.000001     let l:line_numbers_changed = 0
                            
   22              0.000017     for [l:line, l:sign_id, l:name] in a:current_sign_list
   21              0.000023         let l:line_map[l:sign_id] = l:line
   22              0.000005     endfor
                            
   22              0.000009     for l:item in a:loclist
   21              0.000014         if l:item.bufnr == a:buffer
   21              0.000038             let l:lnum = get(l:line_map, get(l:item, 'sign_id', 0), 0)
                            
   21              0.000015             if l:lnum && l:item.lnum != l:lnum
                                            let l:item.lnum = l:lnum
                                            let l:line_numbers_changed = 1
   21              0.000005             endif
   21              0.000005         endif
   22              0.000006     endfor
                            
                                " When the line numbers change, sort the list again
    1              0.000001     if l:line_numbers_changed
                                    call sort(a:loclist, 'ale#util#LocItemCompare')
    1              0.000000     endif

FUNCTION  ale#command#InitData()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/command.vim line 22
Called 61 times
Total time:   0.000351
 Self time:   0.000351

count  total (s)   self (s)
   61              0.000167     if !has_key(s:buffer_data, a:buffer)
    1              0.000004         let s:buffer_data[a:buffer] = {   'jobs': {},   'file_list': [],   'directory_list': [],}
   61              0.000025     endif

FUNCTION  ale#util#LocItemCompare()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/util.vim line 150
Called 42 times
Total time:   0.000368
 Self time:   0.000368

count  total (s)   self (s)
   42              0.000034     if a:left.bufnr < a:right.bufnr
                                    return -1
   42              0.000010     endif
                            
   42              0.000039     if a:left.bufnr > a:right.bufnr
                                    return 1
   42              0.000010     endif
                            
   42              0.000024     if a:left.bufnr == -1
                                    if a:left.filename < a:right.filename
                                        return -1
                                    endif
                            
                                    if a:left.filename > a:right.filename
                                        return 1
                                    endif
   42              0.000009     endif
                            
   42              0.000030     if a:left.lnum < a:right.lnum
   42              0.000017         return -1
                                endif
                            
                                if a:left.lnum > a:right.lnum
                                    return 1
                                endif
                            
                                if a:left.col < a:right.col
                                    return -1
                                endif
                            
                                if a:left.col > a:right.col
                                    return 1
                                endif
                            
                                " When either of the items lacks a problem type, then the two items should
                                " be considered equal. This is important for loclist jumping.
                                if !has_key(a:left, 'type') || !has_key(a:right, 'type')
                                    return 0
                                endif
                            
                                let l:left_priority = ale#util#GetItemPriority(a:left)
                                let l:right_priority = ale#util#GetItemPriority(a:right)
                            
                                if l:left_priority < l:right_priority
                                    return -1
                                endif
                            
                                if l:left_priority > l:right_priority
                                    return 1
                                endif
                            
                                return 0

FUNCTION  ale#highlight#CreatePositions()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/highlight.vim line 48
Called 21 times
Total time:   0.000088
 Self time:   0.000088

count  total (s)   self (s)
   21              0.000020     if a:line >= a:end_line
                                    " For single lines, just return the one position.
   20              0.000043         return [[[a:line, a:col, a:end_col - a:col + 1]]]
    1              0.000000     endif
                            
                                " Get positions from the first line at the first column, up to a large
                                " integer for highlighting up to the end of the line, followed by
                                " the lines in-between, for highlighting entire lines, and
                                " a highlight for the last line, up to the end column.
    1              0.000006     let l:all_positions =   [[a:line, a:col, s:MAX_COL_SIZE]]   + range(a:line + 1, a:end_line - 1)   + [[a:end_line, 1, a:end_col]]
                            
    1              0.000005     return map(   range(0, len(l:all_positions) - 1, s:MAX_POS_VALUES),   'l:all_positions[v:val : v:val + s:MAX_POS_VALUES - 1]',)

FUNCTION  ale#command#ManageDirectory()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/command.vim line 50
Called 20 times
Total time:   0.000296
 Self time:   0.000183

count  total (s)   self (s)
   20   0.000214   0.000101     call ale#command#InitData(a:buffer)
   20              0.000070     call add(s:buffer_data[a:buffer].directory_list, a:directory)

FUNCTION  ale#linter#GetAll()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/linter.vim line 271
Called 20 times
Total time:   0.001247
 Self time:   0.001066

count  total (s)   self (s)
                                " Don't return linters in the sandbox.
                                " Otherwise a sandboxed script could modify them.
   20   0.000342   0.000161     if ale#util#InSandbox()
                                    return []
   20              0.000008     endif
                            
   20              0.000049     let l:combined_linters = []
                            
   60              0.000102     for l:filetype in a:filetypes
                                    " Load linters from runtimepath if we haven't done that yet.
   40              0.000106         if !has_key(s:runtime_loaded_map, l:filetype)
                                        execute 'silent! runtime! ale_linters/' . l:filetype . '/*.vim'
                            
                                        let s:runtime_loaded_map[l:filetype] = 1
   40              0.000017         endif
                            
   40              0.000209         call extend(l:combined_linters, get(s:linters, l:filetype, []))
   60              0.000041     endfor
                            
   20              0.000024     return l:combined_linters

FUNCTION  <SNR>71_Nat()
    Defined: ~/.config/nvim/plugged/vim-polyglot/indent/javascript.vim line 161
Called 2 times
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    2              0.000003   return a:int * (a:int > 0)

FUNCTION  <SNR>253_is_jsx_element()
    Defined: ~/.config/nvim/plugged/vim-polyglot/autoload/jsx_pretty/indent.vim line 71
Called 4 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    4              0.000007   return a:syntax =~? 'jsxElement'

FUNCTION  ale#linter#ResolveFiletype()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/linter.vim line 320
Called 20 times
Total time:   0.001017
 Self time:   0.000320

count  total (s)   self (s)
   20   0.000895   0.000197     let l:filetype = s:GetAliasedFiletype(a:original_filetype)
                            
   20              0.000042     if type(l:filetype) isnot v:t_list
                                    return [l:filetype]
   20              0.000009     endif
                            
   20              0.000020     return l:filetype

FUNCTION  ale#util#Mode()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/util.vim line 5
Called 55 times
Total time:   0.000267
 Self time:   0.000267

count  total (s)   self (s)
   55              0.000219     return call('mode', a:000)

FUNCTION  ale#sign#GetSignCommands()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/sign.vim line 353
Called 1 time
Total time:   0.000505
 Self time:   0.000492

count  total (s)   self (s)
    1              0.000001     let l:command_list = []
    1              0.000001     let l:is_dummy_sign_set = a:was_sign_set
                            
                                " Set the dummy sign if we need to.
                                " The dummy sign is needed to keep the sign column open while we add
                                " and remove signs.
    1              0.000002     if !l:is_dummy_sign_set && (!empty(a:sign_map) || g:ale_sign_column_always)
    1   0.000016   0.000011         call add(l:command_list, 'sign place '   .  g:ale_sign_offset   . s:GroupCmd()   . s:PriorityCmd()   . ' line=1 name=ALEDummySign '   . ' buffer=' . a:buffer)
    1              0.000001         let l:is_dummy_sign_set = 1
    1              0.000000     endif
                            
                                " Place new items first.
   23              0.000026     for [l:line_str, l:info] in items(a:sign_map)
   22              0.000012         if l:info.new_id
                                        " Save the sign IDs we are setting back on our loclist objects.
                                        " These IDs will be used to preserve items which are set many times.
   42              0.000026             for l:item in l:info.items
   21              0.000019                 let l:item.sign_id = l:info.new_id
   42              0.000013             endfor
                            
   21              0.000026             if index(l:info.current_id_list, l:info.new_id) < 0
    1   0.000016   0.000011                 call add(l:command_list, 'sign place '   . (l:info.new_id)   . s:GroupCmd()   . s:PriorityCmd()   . ' line=' . l:line_str   . ' name=' . (l:info.new_name)   . ' buffer=' . a:buffer)
   21              0.000006             endif
   22              0.000005         endif
   23              0.000007     endfor
                            
                                " Remove signs without new IDs.
   23              0.000014     for l:info in values(a:sign_map)
   43              0.000027         for l:current_id in l:info.current_id_list
   21              0.000016             if l:current_id isnot l:info.new_id
    1   0.000014   0.000011                 call add(l:command_list, 'sign unplace '   . l:current_id   . s:GroupCmd()   . ' buffer=' . a:buffer)
   21              0.000006             endif
   43              0.000013         endfor
   23              0.000018     endfor
                            
                                " Remove the dummy sign to close the sign column if we need to.
    1              0.000001     if l:is_dummy_sign_set && !g:ale_sign_column_always
    1   0.000008   0.000006         call add(l:command_list, 'sign unplace '   . g:ale_sign_offset   . s:GroupCmd()   . ' buffer=' . a:buffer)
    1              0.000000     endif
                            
    1              0.000001     return l:command_list

FUNCTION  ale#util#InSandbox()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/util.vim line 289
Called 77 times
Total time:   0.001066
 Self time:   0.000990

count  total (s)   self (s)
   77              0.000078     try
   77   0.000581   0.000505         let &l:equalprg=&l:equalprg
                                catch /E48/
                                    " E48 is the sandbox error.
                                    return 1
   77              0.000062     endtry
                            
   77              0.000068     return 0

FUNCTION  <SNR>17_Autocmd()
    Defined: ~/.config/nvim/plugged/coc.nvim/plugin/coc.vim line 231
Called 112 times
Total time:   0.015548
 Self time:   0.001683

count  total (s)   self (s)
  112              0.000319   if !g:coc_workspace_initialized
                                return
  112              0.000110   endif
  112   0.014825   0.000960   call coc#rpc#notify('CocAutocmd', a:000)

FUNCTION  <SNR>259_BuildSignMap()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/sign.vim line 284
Called 1 time
Total time:   0.001150
 Self time:   0.000640

count  total (s)   self (s)
    1   0.000011   0.000004     let l:max_signs = ale#Var(a:buffer, 'max_signs')
                            
    1              0.000001     if l:max_signs is 0
                                    let l:selected_grouped_items = []
    1              0.000002     elseif type(l:max_signs) is v:t_number && l:max_signs > 0
                                    let l:selected_grouped_items = a:grouped_items[:l:max_signs - 1]
    1              0.000000     else
    1              0.000001         let l:selected_grouped_items = a:grouped_items
    1              0.000000     endif
                            
    1              0.000001     let l:sign_map = {}
    1              0.000001     let l:sign_offset = g:ale_sign_offset
                            
   22              0.000017     for [l:line, l:sign_id, l:name] in a:current_sign_list
   21              0.000068         let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
                                    " Increment the sign offset for new signs, by the maximum sign ID.
   21              0.000017         if l:sign_id > l:sign_offset
   11              0.000008             let l:sign_offset = l:sign_id
   21              0.000005         endif
                            
                                    " Remember the sign names and IDs in separate Lists, so they are easy
                                    " to work with.
   21              0.000022         call add(l:sign_info.current_id_list, l:sign_id)
   21              0.000023         call add(l:sign_info.current_name_list, l:name)
                            
   21              0.000024         let l:sign_map[l:line] = l:sign_info
   22              0.000006     endfor
                            
   22              0.000012     for l:group in l:selected_grouped_items
   21              0.000020         let l:line = l:group[0].lnum
   21              0.000078         let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
   21   0.000590   0.000087         let l:sign_info.new_name = ale#sign#GetSignName(l:group)
   21              0.000020         let l:sign_info.items = l:group
                            
   21              0.000034         let l:index = index(   l:sign_info.current_name_list,   l:sign_info.new_name)
                            
   21              0.000014         if l:index >= 0
                                        " We have a sign with this name already, so use the same ID.
   20              0.000025             let l:sign_info.new_id = l:sign_info.current_id_list[l:index]
    1              0.000000         else
                                        " This sign name replaces the previous name, so use a new ID.
    1              0.000001             let l:sign_info.new_id = l:sign_offset + 1
    1              0.000001             let l:sign_offset += 1
   21              0.000005         endif
                            
   21              0.000025         let l:sign_map[l:line] = l:sign_info
   22              0.000007     endfor
                            
    1              0.000001     return l:sign_map

FUNCTION  ale#node#FindExecutable()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/node.vim line 10
Called 60 times
Total time:   2.053877
 Self time:   0.001521

count  total (s)   self (s)
   60   0.001014   0.000349     if ale#Var(a:buffer, a:base_var_name . '_use_global')
                                    return ale#Var(a:buffer, a:base_var_name . '_executable')
   60              0.000027     endif
                            
   60   2.051948   0.000488     let l:nearest = ale#node#FindNearestExecutable(a:buffer, a:path_list)
                            
   60              0.000086     if !empty(l:nearest)
   40              0.000036         return l:nearest
   20              0.000007     endif
                            
   20   0.000489   0.000257     return ale#Var(a:buffer, a:base_var_name . '_executable')

FUNCTION  syntastic#log#debugDump()
    Defined: ~/.config/nvim/plugged/syntastic/autoload/syntastic/log.vim line 122
Called 4 times
Total time:   0.000026
 Self time:   0.000020

count  total (s)   self (s)
    4   0.000023   0.000017     if !s:_isDebugEnabled(a:level)
    4              0.000002         return
                                endif
                            
                                call syntastic#log#debugShowVariables( a:level, sort(keys(g:_SYNTASTIC_DEFAULTS)) )

FUNCTION  <SNR>211_RunIfExecutable()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/engine.vim line 527
Called 20 times
Total time:   1.698273
 Self time:   0.001655

count  total (s)   self (s)
   20   0.000205   0.000115     if ale#command#IsDeferred(a:executable)
                                    let a:executable.result_callback = {   executable -> s:RunIfExecutable(       a:buffer,       a:linter,       a:lint_file,       executable   )}
                            
                                    return 1
   20              0.000017     endif
                            
   20   0.000313   0.000106     if ale#engine#IsExecutable(a:buffer, a:executable)
                                    " Use different job types for file or linter jobs.
   20              0.000036         let l:job_type = a:lint_file ? 'file_linter' : 'linter'
   20              0.000101         call setbufvar(a:buffer, 'ale_job_type', l:job_type)
                            
                                    " Get the cwd for the linter and set it before we call GetCommand.
                                    " This will ensure that ale#command#Run uses it by default.
   20   0.808221   0.000134         let l:cwd = ale#linter#GetCwd(a:buffer, a:linter)
                            
   20              0.000029         if l:cwd isnot v:null
   20   0.000581   0.000261             call ale#command#SetCwd(a:buffer, l:cwd)
   20              0.000008         endif
                            
   20   0.812728   0.000133         let l:command = ale#linter#GetCommand(a:buffer, a:linter)
                            
   20              0.000031         if l:cwd isnot v:null
   20   0.000263   0.000143             call ale#command#ResetCwd(a:buffer)
   20              0.000007         endif
                            
   20              0.000149         let l:options = {   'cwd': l:cwd,   'executable': a:executable,   'buffer': a:buffer,   'linter': a:linter,   'output_stream': get(a:linter, 'output_stream', 'stdout'),   'read_buffer': a:linter.read_buffer,   'lint_file': a:lint_file,}
                            
   20   0.075371   0.000173         return s:RunJob(l:command, l:options)
                                endif
                            
                                return 0

FUNCTION  ale#handlers#eslint#GetExecutable()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/handlers/eslint.vim line 38
Called 40 times
Total time:   1.648568
 Self time:   0.000325

count  total (s)   self (s)
   40   1.648546   0.000303     return ale#node#FindExecutable(a:buffer, 'javascript_eslint', s:executables)

FUNCTION  ale#util#GetLineCount()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/util.vim line 83
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000018     return len(getbufline(a:buffer, 1, '$'))

FUNCTION  ale#engine#FixLocList()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/engine.vim line 259
Called 1 time
Total time:   0.001191
 Self time:   0.001146

count  total (s)   self (s)
    1   0.000025   0.000005     let l:mappings = ale#GetFilenameMappings(a:buffer, a:linter_name)
                            
    1              0.000001     if !empty(l:mappings)
                                    " We need to apply reverse filename mapping here.
                                    let l:mappings = ale#filename_mapping#Invert(l:mappings)
    1              0.000000     endif
                            
    1              0.000001     let l:bufnr_map = {}
    1              0.000001     let l:new_loclist = []
                            
                                " Some errors have line numbers beyond the end of the file,
                                " so we need to adjust them so they set the error at the last line
                                " of the file instead.
    1   0.000023   0.000005     let l:last_line_number = ale#util#GetLineCount(a:buffer)
                            
   22              0.000013     for l:old_item in a:loclist
                                    " Copy the loclist item with some default values and corrections.
                                    "
                                    " line and column numbers will be converted to numbers.
                                    " The buffer will default to the buffer being checked.
                                    " The vcol setting will default to 0, a byte index.
                                    " The error type will default to 'E' for errors.
                                    " The error number will default to -1.
                                    "
                                    " The line number and text are the only required keys.
                                    "
                                    " The linter_name will be set on the errors so it can be used in
                                    " output, filtering, etc..
   21              0.000149         let l:item = {   'bufnr': a:buffer,   'text': l:old_item.text,   'lnum': str2nr(l:old_item.lnum),   'col': str2nr(get(l:old_item, 'col', 0)),   'vcol': 0,   'type': get(l:old_item, 'type', 'E'),   'nr': get(l:old_item, 'nr', -1),   'linter_name': a:linter_name,}
                            
   21              0.000013         if a:from_other_source
                                        let l:item.from_other_source = 1
   21              0.000005         endif
                            
   21              0.000021         if has_key(l:old_item, 'code')
   21              0.000019             let l:item.code = l:old_item.code
   21              0.000005         endif
                            
   21              0.000032         let l:old_name = get(l:old_item, 'filename', '')
                            
                                    " Map parsed from output to local filesystem files.
   21              0.000027         if !empty(l:old_name) && !empty(l:mappings)
                                        let l:old_name = ale#filename_mapping#Map(l:old_name, l:mappings)
   21              0.000005         endif
                            
   21              0.000029         if !empty(l:old_name) && !ale#path#IsTempName(l:old_name)
                                        " Use the filename given.
                                        " Temporary files are assumed to be for this buffer,
                                        " and the filename is not included then, because it looks bad
                                        " in the loclist window.
                                        let l:filename = l:old_name
                                        let l:item.filename = l:filename
                            
                                        if has_key(l:old_item, 'bufnr')
                                            " If a buffer number is also given, include that too.
                                            " If Vim detects that he buffer number is valid, it will
                                            " be used instead of the filename.
                                            let l:item.bufnr = l:old_item.bufnr
                                        elseif has_key(l:bufnr_map, l:filename)
                                            " Get the buffer number from the map, which can be faster.
                                            let l:item.bufnr = l:bufnr_map[l:filename]
                                        else
                                            " Look up the buffer number.
                                            let l:item.bufnr = bufnr(l:filename)
                                            let l:bufnr_map[l:filename] = l:item.bufnr
                                        endif
   21              0.000020         elseif has_key(l:old_item, 'bufnr')
                                        let l:item.bufnr = l:old_item.bufnr
   21              0.000005         endif
                            
   21              0.000019         if has_key(l:old_item, 'detail')
                                        let l:item.detail = l:old_item.detail
   21              0.000005         endif
                            
                                    " Pass on a end_col key if set, used for highlights.
   21              0.000019         if has_key(l:old_item, 'end_col')
   21              0.000028             let l:item.end_col = str2nr(l:old_item.end_col)
   21              0.000005         endif
                            
   21              0.000019         if has_key(l:old_item, 'end_lnum')
   21              0.000027             let l:item.end_lnum = str2nr(l:old_item.end_lnum)
   21              0.000005         endif
                            
   21              0.000019         if has_key(l:old_item, 'sub_type')
                                        let l:item.sub_type = l:old_item.sub_type
   21              0.000004         endif
                            
   21              0.000014         if l:item.lnum < 1
                                        " When errors appear before line 1, put them at line 1.
                                        let l:item.lnum = 1
   21              0.000028         elseif l:item.bufnr == a:buffer && l:item.lnum > l:last_line_number
                                        " When errors go beyond the end of the file, put them at the end.
                                        " This is only done for the current buffer.
                                        let l:item.lnum = l:last_line_number
   21              0.000021         elseif get(l:old_item, 'vcol', 0)
                                        " Convert virtual column positions to byte positions.
                                        " The positions will be off if the buffer has changed recently.
                                        let l:line = getbufline(a:buffer, l:item.lnum)[0]
                            
                                        let l:item.col = ale#util#Col(l:line, l:item.col)
                            
                                        if has_key(l:item, 'end_col')
                                            let l:end_line = get(l:item, 'end_lnum', l:line) != l:line   ? getbufline(a:buffer, l:item.end_lnum)[0]   : l:line
                            
                                            let l:item.end_col = ale#util#Col(l:end_line, l:item.end_col)
                                        endif
   21              0.000004         endif
                            
   21              0.000025         call add(l:new_loclist, l:item)
   22              0.000009     endfor
                            
    1   0.000013   0.000006     let l:type_map = get(ale#Var(a:buffer, 'type_map'), a:linter_name, {})
                            
    1              0.000001     if !empty(l:type_map)
                                    call s:RemapItemTypes(l:type_map, l:new_loclist)
    1              0.000000     endif
                            
    1              0.000001     return l:new_loclist

FUNCTION  43()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/loclist.vim line 60
Called 3 times
Total time:   0.000061
 Self time:   0.000025

count  total (s)   self (s)
    3              0.000004     if !exists('self._stamp')
                                    let self._stamp = []
                                    return 0
    3              0.000001     endif
    3   0.000050   0.000015     return syntastic#util#compareLexi(self._stamp, a:stamp) > 0

FUNCTION  coc#_do_complete()
    Defined: ~/.config/nvim/plugged/coc.nvim/autoload/coc.vim line 61
Called 1 time
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    1              0.000009   let g:coc#_context = { 'start': a:start, 'candidates': a:items, 'preselect': a:preselect}
    1              0.000007   if mode() =~# 'i' && &paste != 1
    1              0.000006     call feedkeys("\<Plug>CocRefresh", 'i')
    1              0.000001   endif

FUNCTION  <SNR>40_QuitPreHook()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic.vim line 370
Called 1 time
Total time:   0.002130
 Self time:   0.000050

count  total (s)   self (s)
    1   0.002024   0.000009     let buf = syntastic#util#fname2buf(a:fname)
    1   0.000030   0.000017     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: QuitPre, buffer ' . buf . ' = ' . string(a:fname))
                            
    1   0.000024   0.000005     if !syntastic#util#var('check_on_wq')
    1   0.000039   0.000006         call syntastic#util#setWids()
    1              0.000005         call add(s:_quit_pre, buf . '_' . getbufvar(buf, 'changetick') . '_' . w:syntastic_wid)
    1              0.000000     endif
                            
    1              0.000003     if !empty(get(w:, 'syntastic_loclist_set', []))
                                    call SyntasticLoclistHide()
    1              0.000000     endif

FUNCTION  ale#highlight#SetHighlights()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/highlight.vim line 205
Called 1 time
Total time:   0.001913
 Self time:   0.000060

count  total (s)   self (s)
    1              0.000021     let l:new_list = getbufvar(a:buffer, 'ale_enabled', 1) && g:ale_enabled   ? filter(copy(a:loclist), 'v:val.bufnr == a:buffer && v:val.col > 0')   : []
                            
                                " Set the list in the buffer variable.
    1              0.000021     call setbufvar(str2nr(a:buffer), 'ale_highlight_items', l:new_list)
                            
    1   0.000015   0.000008     let l:exclude_list = ale#Var(a:buffer, 'exclude_highlights')
                            
    1              0.000001     if !empty(l:exclude_list)
                                    call filter(l:new_list, 'empty(ale#util#GetMatches(v:val.text, l:exclude_list))')
    1              0.000000     endif
                            
                                " Update highlights for the current buffer, which may or may not
                                " be the buffer we just set highlights for.
    1   0.001852   0.000005     call ale#highlight#UpdateHighlights()

FUNCTION  ale#engine#SetResults()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/engine.vim line 184
Called 1 time
Total time:   0.010245
 Self time:   0.000090

count  total (s)   self (s)
    1   0.000014   0.000006     let l:linting_is_done = !ale#engine#IsCheckingBuffer(a:buffer)
                            
                                " Set signs first. This could potentially fix some line numbers.
                                " The List could be sorted again here by SetSigns.
    1              0.000001     if g:ale_set_signs
    1   0.002826   0.000020         call ale#sign#SetSigns(a:buffer, a:loclist)
    1              0.000000     endif
                            
    1              0.000002     if g:ale_set_quickfix || g:ale_set_loclist
    1   0.004181   0.000011         call ale#list#SetLists(a:buffer, a:loclist)
    1              0.000000     endif
                            
    1              0.000002     if exists('*ale#statusline#Update')
                                    " Don't load/run if not already loaded.
                                    call ale#statusline#Update(a:buffer, a:loclist)
    1              0.000000     endif
                            
    1              0.000001     if g:ale_set_highlights
    1   0.001919   0.000006         call ale#highlight#SetHighlights(a:buffer, a:loclist)
    1              0.000000     endif
                            
    1              0.000001     if l:linting_is_done
    1              0.000001         if g:ale_echo_cursor
                                        " Try and echo the warning now.
                                        " This will only do something meaningful if we're in normal mode.
    1   0.000237   0.000006             call ale#cursor#EchoCursorWarning()
    1              0.000000         endif
                            
    1              0.000001         if g:ale_virtualtext_cursor
                                        " Try and show the warning now.
                                        " This will only do something meaningful if we're in normal mode.
                                        call ale#virtualtext#ShowCursorWarning()
    1              0.000000         endif
                            
                                    " Reset the save event marker, used for opening windows, etc.
    1              0.000002         call setbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Set a marker showing how many times a buffer has been checked.
    1              0.000003         call setbufvar(   a:buffer,   'ale_linted',   getbufvar(a:buffer, 'ale_linted', 0) + 1)
                            
                                    " Automatically remove all managed temporary files and directories
                                    " now that all jobs have completed.
    1   0.001035   0.000010         call ale#command#RemoveManagedFiles(a:buffer)
                            
                                    " Call user autocommands. This allows users to hook into ALE's lint cycle.
    1   0.000008   0.000007         silent doautocmd <nomodeline> User ALELintPost
    1              0.000000     endif

FUNCTION  <SNR>259_GroupLoclistItems()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/sign.vim line 238
Called 1 time
Total time:   0.000143
 Self time:   0.000143

count  total (s)   self (s)
    1              0.000001     let l:grouped_items = []
    1              0.000001     let l:last_lnum = -1
                            
   22              0.000010     for l:obj in a:loclist
   21              0.000015         if l:obj.bufnr != a:buffer
                                        continue
   21              0.000004         endif
                            
                                    " Create a new sub-List when we hit a new line.
   21              0.000014         if l:obj.lnum != l:last_lnum
   21              0.000019             call add(l:grouped_items, [])
   21              0.000005         endif
                            
   21              0.000023         call add(l:grouped_items[-1], l:obj)
   21              0.000017         let l:last_lnum = l:obj.lnum
   22              0.000007     endfor
                            
    1              0.000001     return l:grouped_items

FUNCTION  ale#sign#ParseSigns()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/sign.vim line 207
Called 1 time
Total time:   0.000675
 Self time:   0.000664

count  total (s)   self (s)
    1   0.000015   0.000005     let l:pattern =ale#sign#ParsePattern()
    1              0.000001     let l:result = []
    1              0.000001     let l:is_dummy_sign_set = 0
                            
   24              0.000016     for l:line in a:line_list
   23              0.000441         let l:match = matchlist(l:line, l:pattern)
                            
   23              0.000037         if len(l:match) > 0
   21              0.000022             if l:match[3] is# 'ALEDummySign'
                                            let l:is_dummy_sign_set = 1
   21              0.000006             else
   21              0.000068                 call add(l:result, [   str2nr(l:match[1]),   str2nr(l:match[2]),   l:match[3],])
   21              0.000007             endif
   23              0.000006         endif
   24              0.000010     endfor
                            
    1              0.000002     return [l:is_dummy_sign_set, l:result]

FUNCTION  <SNR>71_PreviousToken()
    Defined: ~/.config/nvim/plugged/vim-polyglot/indent/javascript.vim line 173
Called 2 times
Total time:   0.000107
 Self time:   0.000080

count  total (s)   self (s)
    2              0.000008   let [l:pos, tok] = [getpos('.'), '']
    2              0.000021   if search('\m\k\{1,}\|\S','ebW')
    2              0.000006     if getline('.')[col('.')-2:col('.')-1] == '*/'
                                  if eval(s:in_comm) && !s:SearchLoop('\S\ze\_s*\/[/*]','bW',s:in_comm)
                                    call setpos('.',l:pos)
                                  else
                                    let tok = s:Token()
                                  endif
    2              0.000001     else
    2              0.000009       let two = a:0 || line('.') != l:pos[1] ? strridx(getline('.')[:col('.')],'//') + 1 : 0
    2              0.000002       if two && eval(s:in_comm)
                                    call cursor(0,two)
                                    let tok = s:PreviousToken(1)
                                    if tok is ''
                                      call setpos('.',l:pos)
                                    endif
    2              0.000000       else
    2   0.000035   0.000008         let tok = s:Token()
    2              0.000001       endif
    2              0.000001     endif
    2              0.000001   endif
    2              0.000001   return tok

FUNCTION  ale#sign#GetSignName()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/sign.vim line 120
Called 21 times
Total time:   0.000503
 Self time:   0.000356

count  total (s)   self (s)
   21              0.000025     let l:priority = g:ale#util#style_warning_priority
                            
                                " Determine the highest priority item for the line.
   42              0.000029     for l:item in a:sublist
   21   0.000234   0.000087         let l:item_priority = ale#util#GetItemPriority(l:item)
                            
   21              0.000019         if l:item_priority > l:priority
   21              0.000018             let l:priority = l:item_priority
   21              0.000006         endif
   42              0.000015     endfor
                            
   21              0.000020     if l:priority is# g:ale#util#error_priority
                                    return 'ALEErrorSign'
   21              0.000006     endif
                            
   21              0.000018     if l:priority is# g:ale#util#warning_priority
   21              0.000013         return 'ALEWarningSign'
                                endif
                            
                                if l:priority is# g:ale#util#style_error_priority
                                    return 'ALEStyleErrorSign'
                                endif
                            
                                if l:priority is# g:ale#util#style_warning_priority
                                    return 'ALEStyleWarningSign'
                                endif
                            
                                if l:priority is# g:ale#util#info_priority
                                    return 'ALEInfoSign'
                                endif
                            
                                " Use the error sign for invalid severities.
                                return 'ALEErrorSign'

FUNCTION  <SNR>212_TemporaryFilename()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/command.vim line 132
Called 20 times
Total time:   0.000736
 Self time:   0.000361

count  total (s)   self (s)
   20              0.000064     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
   20              0.000022     if empty(l:filename)
                                    " If the buffer's filename is empty, create a dummy filename.
                                    let l:ft = getbufvar(a:buffer, '&filetype')
                                    let l:filename = 'file' . ale#filetypes#GuessExtension(l:ft)
   20              0.000008     endif
                            
                                " Create a temporary filename, <temp_dir>/<original_basename>
                                " The file itself will not be created by this function.
   20   0.000549   0.000174     return ale#util#Tempname() . (has('win32') ? '\' : '/') . l:filename

FUNCTION  coc#_complete()
    Defined: ~/.config/nvim/plugged/coc.nvim/autoload/coc.vim line 49
Called 2 times
Total time:   0.000483
 Self time:   0.000262

count  total (s)   self (s)
    2              0.000009   let items = get(g:coc#_context, 'candidates', [])
    2              0.000005   let preselect = get(g:coc#_context, 'preselect', -1)
    2   0.000449   0.000227   call complete( g:coc#_context.start + 1, items)
    2              0.000009   if s:select_api && len(items) && preselect != -1
                                call nvim_select_popupmenu_item(preselect, v:false, v:false, {})
    2              0.000001   endif
    2              0.000002   return ''

FUNCTION  syntastic#util#fname2buf()
    Defined: ~/.config/nvim/plugged/syntastic/autoload/syntastic/util.vim line 306
Called 5 times
Total time:   0.009966
 Self time:   0.009966

count  total (s)   self (s)
    5              0.000019     if exists('+shellslash')
                                    " bufnr() can't cope with backslashes
                                    let old_shellslash = &shellslash
                                    let &shellslash = 1
    5              0.000003     endif
                            
                                " this is a best-effort attempt to escape file patterns (cf. :h file-pattern)
                                " XXX it fails for filenames containing something like \{2,3}
    5              0.000007     let buf = -1
    5              0.000014     for md in [':~:.', ':~', ':p']
    5              0.000006         try
                                        " Older versions of Vim can throw E94 here
    5              0.009787             let buf = bufnr('^' . escape(fnamemodify(a:fname, md), '\*?,{}[') . '$')
                                    catch
                                        " catch everything
    5              0.000007         endtry
    5              0.000009         if buf != -1
    5              0.000003             break
                                    endif
    5              0.000013     endfor
    5              0.000006     if buf == -1
                                    " XXX definitely wrong, but hope is the last thing to die :)
                                    let buf = bufnr(fnamemodify(a:fname, ':p'))
    5              0.000002     endif
                            
    5              0.000012     if exists('+shellslash')
                                    let &shellslash = old_shellslash
    5              0.000002     endif
                            
    5              0.000007     return buf

FUNCTION  <SNR>217_parseJSON()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/handlers/eslint.vim line 111
Called 1 time
Total time:   0.000558
 Self time:   0.000558

count  total (s)   self (s)
    1              0.000001     let l:parsed = []
                            
    2              0.000003     for l:line in a:lines
    1              0.000000         try
    1              0.000088             let l:parsed = extend(l:parsed, json_decode(l:line))
                                    catch
    1              0.000001         endtry
    2              0.000001     endfor
                            
    1              0.000003     if type(l:parsed) != v:t_list || empty(l:parsed)
                                    return []
    1              0.000000     endif
                            
    1              0.000002     let l:errors = l:parsed[0]['messages']
                            
    1              0.000001     if empty(l:errors)
                                    return []
    1              0.000000     endif
                            
    1              0.000001     let l:output = []
                            
   22              0.000011     for l:error in l:errors
   21              0.000073         let l:obj = ({   'lnum': get(l:error, 'line', 0),   'text': get(l:error, 'message', ''),   'type': 'E',})
                            
   21              0.000024         if get(l:error, 'severity', 0) is# 1
   21              0.000014             let l:obj.type = 'W'
   21              0.000005         endif
                            
   21              0.000021         if has_key(l:error, 'ruleId')
   21              0.000020             let l:code = l:error['ruleId']
                            
                                        " Sometimes ESLint returns null here
   21              0.000018             if !empty(l:code)
   21              0.000017                 let l:obj.code = l:code
   21              0.000006             endif
   21              0.000005         endif
                            
   21              0.000021         if has_key(l:error, 'column')
   21              0.000021             let l:obj.col = l:error['column']
   21              0.000005         endif
                            
   21              0.000021         if has_key(l:error, 'endColumn')
   21              0.000024             let l:obj.end_col = l:error['endColumn'] - 1
   21              0.000005         endif
                            
   21              0.000021         if has_key(l:error, 'endLine')
   21              0.000022             let l:obj.end_lnum = l:error['endLine']
   21              0.000005         endif
                            
   21              0.000024         call add(l:output, l:obj)
   22              0.000007     endfor
                            
    1              0.000001     return l:output

FUNCTION  syntastic#util#rawVar()
    Defined: ~/.config/nvim/plugged/syntastic/autoload/syntastic/util.vim line 165
Called 43 times
Total time:   0.000179
 Self time:   0.000179

count  total (s)   self (s)
   43              0.000166     return get(b:, a:name, get(g:, a:name, a:0 ? a:1 : ''))

FUNCTION  <SNR>200_GetLinterNames()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/linter.vim line 330
Called 20 times
Total time:   0.000580
 Self time:   0.000580

count  total (s)   self (s)
   20              0.000061     let l:buffer_ale_linters = get(b:, 'ale_linters', {})
                            
                                " b:ale_linters can be set to 'all'
   20              0.000027     if l:buffer_ale_linters is# 'all'
                                    return 'all'
   20              0.000007     endif
                            
                                " b:ale_linters can be set to a List.
   20              0.000037     if type(l:buffer_ale_linters) is v:t_list
                                    return l:buffer_ale_linters
   20              0.000008     endif
                            
                                " Try to get a buffer-local setting for the filetype
   20              0.000041     if has_key(l:buffer_ale_linters, a:original_filetype)
                                    return l:buffer_ale_linters[a:original_filetype]
   20              0.000007     endif
                            
                                " Try to get a global setting for the filetype
   20              0.000043     if has_key(g:ale_linters, a:original_filetype)
                                    return g:ale_linters[a:original_filetype]
   20              0.000007     endif
                            
                                " If the user has configured ALE to only enable linters explicitly, then
                                " don't enable any linters by default.
   20              0.000028     if g:ale_linters_explicit
                                    return []
   20              0.000008     endif
                            
                                " Try to get a default setting for the filetype
   20              0.000049     if has_key(s:default_ale_linters, a:original_filetype)
   20              0.000036         return s:default_ale_linters[a:original_filetype]
                                endif
                            
                                return 'all'

FUNCTION  ale#node#Executable()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/node.vim line 46
Called 20 times
Total time:   0.000603
 Self time:   0.000333

count  total (s)   self (s)
   20              0.000131     if has('win32') && a:executable =~? '\.js$'
                                    let l:node = ale#Var(a:buffer, 'windows_node_executable_path')
                            
                                    return ale#Escape(l:node) . ' ' . ale#Escape(a:executable)
   20              0.000016     endif
                            
   20   0.000359   0.000089     return ale#Escape(a:executable)

FUNCTION  ale#command#CreateTempFile()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/command.vim line 110
Called 20 times
Total time:   0.009059
 Self time:   0.001985

count  total (s)   self (s)
   20              0.000026     if empty(a:temporary_file)
                                    " There is no file, so we didn't create anything.
                                    return 0
   20              0.000006     endif
                            
                                " Use an existing list of lines of input if we have it, or get the lines
                                " from the file.
   20              0.000321     let l:lines = a:input isnot v:null ? a:input : getbufline(a:buffer, 1, '$')
                            
   20              0.000053     let l:temporary_directory = fnamemodify(a:temporary_file, ':h')
                                " Create the temporary directory for the file, unreadable by 'other'
                                " users.
   20              0.001117     call mkdir(l:temporary_directory, '', 0750)
                                " Automatically delete the directory later.
   20   0.000452   0.000156     call ale#command#ManageDirectory(a:buffer, l:temporary_directory)
                                " Write the buffer out to a file.
   20   0.006971   0.000193     call ale#util#Writefile(a:buffer, l:lines, a:temporary_file)
                            
   20              0.000026     return 1

FUNCTION  <SNR>71_SearchLoop()
    Defined: ~/.config/nvim/plugged/vim-polyglot/indent/javascript.vim line 202
Called 4 times
Total time:   0.005019
 Self time:   0.000026

count  total (s)   self (s)
    4   0.005018   0.000025   return s:GetPair(a:pat,'\_$.',a:flags,a:expr)

FUNCTION  <lambda>3()
    Defined: ~/.config/nvim/plugged/ale/ale_linters/vue/vls.vim line 21
Called 20 times
Total time:   0.405823
 Self time:   0.000189

count  total (s)   self (s)
   20   0.405810   0.000176 return ale#node#FindExecutable(b, 'vue_vls', [       'node_modules/.bin/vls',   ])

FUNCTION  ale#engine#HandleLoclist()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/engine.vim line 108
Called 1 time
Total time:   0.012038
 Self time:   0.000161

count  total (s)   self (s)
    1              0.000002     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
    1              0.000001     if empty(l:info)
                                    return
    1              0.000000     endif
                            
    1              0.000001     if !a:from_other_source
                                    " Remove this linter from the list of active linters.
                                    " This may have already been done when the job exits.
    1              0.000002         call filter(l:info.active_linter_list, 'v:val.name isnot# a:linter_name')
    1              0.000000     endif
                            
                                " Make some adjustments to the loclists to fix common problems, and also
                                " to set default values for loclist items.
    1   0.001198   0.000007     let l:linter_loclist = ale#engine#FixLocList(   a:buffer,   a:linter_name,   a:from_other_source,   a:loclist,)
                            
                                " Remove previous items for this linter.
    1              0.000022     call filter(l:info.loclist, 'v:val.linter_name isnot# a:linter_name')
                            
                                " We don't need to add items or sort the list when this list is empty.
    1              0.000001     if !empty(l:linter_loclist)
                                    " Add the new items.
    1              0.000002         call extend(l:info.loclist, l:linter_loclist)
                            
                                    " Sort the loclist again.
                                    " We need a sorted list so we can run a binary search against it
                                    " for efficient lookup of the messages in the cursor handler.
    1   0.000471   0.000103         call sort(l:info.loclist, 'ale#util#LocItemCompare')
    1              0.000000     endif
                            
    1   0.000078   0.000004     if ale#ShouldDoNothing(a:buffer)
                                    return
    1              0.000000     endif
                            
    1   0.010252   0.000007     call ale#engine#SetResults(a:buffer, l:info.loclist)

FUNCTION  <SNR>198_Lint()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale.vim line 99
Called 20 times
Total time:   3.702123
 Self time:   0.022558

count  total (s)   self (s)
                                " Use the filetype from the buffer
   20              0.000068     let l:filetype = getbufvar(a:buffer, '&filetype')
   20   0.008737   0.000167     let l:linters = ale#linter#Get(l:filetype)
   20   0.001071   0.000253     let l:linters = ale#linter#RemoveIgnored(a:buffer, l:filetype, l:linters)
                            
                                " Tell other sources that they can start checking the buffer now.
   20              0.000063     let g:ale_want_results_buffer = a:buffer
   20   0.000251   0.000229     silent doautocmd <nomodeline> User ALEWantResults
   20              0.000065     unlet! g:ale_want_results_buffer
                            
                                " Don't set up buffer data and so on if there are no linters to run.
   20              0.000075     if !has_key(g:ale_buffer_info, a:buffer) && empty(l:linters)
                                    return
   20              0.000009     endif
                            
                                " Clear lint_file linters, or only run them if the file exists.
   20              0.021256     let l:lint_file = empty(l:linters)   || (a:should_lint_file && filereadable(expand('#' . a:buffer . ':p')))
                            
   20   3.670401   0.000246     call ale#engine#RunLinters(a:buffer, l:linters, l:lint_file)

FUNCTION  <SNR>211_RunLinter()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/engine.vim line 579
Called 40 times
Total time:   3.659219
 Self time:   0.000879

count  total (s)   self (s)
   40              0.000090     if !empty(a:linter.lsp)
   20   1.122317   0.000148         return ale#lsp_linter#CheckWithLSP(a:buffer, a:linter)
   20              0.000009     else
   20   0.838058   0.000159         let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                            
   20   1.698653   0.000381         return s:RunIfExecutable(a:buffer, a:linter, a:lint_file, l:executable)
                                endif
                            
                                return 0

FUNCTION  <SNR>211_RemoveProblemsForDisabledLinters()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/engine.vim line 477
Called 20 times
Total time:   0.002059
 Self time:   0.002059

count  total (s)   self (s)
                                " Figure out which linters are still enabled, and remove
                                " problems for linters which are no longer enabled.
                                " Problems from other sources will be kept.
   20              0.000032     let l:name_map = {}
                            
   60              0.000073     for l:linter in a:linters
   40              0.000105         let l:name_map[l:linter.name] = 1
   60              0.000043     endfor
                            
   20              0.001724     call filter(   get(g:ale_buffer_info[a:buffer], 'loclist', []),   'get(v:val, ''from_other_source'') || get(l:name_map, get(v:val, ''linter_name''))',)

FUNCTION  ale#history#Get()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/history.vim line 8
Called 2 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    2              0.000010     return copy(getbufvar(a:buffer, 'ale_history', []))

FUNCTION  syntastic#util#unique()
    Defined: ~/.config/nvim/plugged/syntastic/autoload/syntastic/util.vim line 341
Called 15 times
Total time:   0.000388
 Self time:   0.000388

count  total (s)   self (s)
   15              0.000022     let seen = {}
   15              0.000016     let uniques = []
   39              0.000063     for e in a:list
   24              0.000048         let k = string(e)
   24              0.000039         if !has_key(seen, k)
   18              0.000027             let seen[k] = 1
   18              0.000036             call add(uniques, e)
   24              0.000011         endif
   39              0.000021     endfor
   15              0.000013     return uniques

FUNCTION  <SNR>211_StopCurrentJobs()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/engine.vim line 449
Called 20 times
Total time:   0.002769
 Self time:   0.000835

count  total (s)   self (s)
   20              0.000084     let l:info = get(g:ale_buffer_info, a:buffer, {})
   20   0.002001   0.000143     call ale#command#StopJobs(a:buffer, 'linter')
                            
                                " Update the active linter list, clearing out anything not running.
   20              0.000024     if a:clear_lint_file_jobs
    3   0.000111   0.000034         call ale#command#StopJobs(a:buffer, 'file_linter')
    3              0.000009         let l:info.active_linter_list = []
   17              0.000008     else
   17              0.000026         let l:lint_file_map = {}
                            
                                    " Use a previously computed map of `lint_file` values to find
                                    " linters that are used for linting files.
   51              0.000088         for [l:lint_file, l:linter] in a:linter_slots
   34              0.000035             if l:lint_file is 1
                                            let l:lint_file_map[l:linter.name] = 1
   34              0.000013             endif
   51              0.000026         endfor
                            
                                    " Keep jobs for linting files when we're only linting buffers.
   17              0.000112         call filter(l:info.active_linter_list, 'get(l:lint_file_map, v:val.name)')
   20              0.000011     endif

FUNCTION  syntastic#util#setLastTick()
    Defined: ~/.config/nvim/plugged/syntastic/autoload/syntastic/util.vim line 411
Called 6 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    6              0.000018     call setbufvar(a:buf, 'syntastic_lasttick', getbufvar(a:buf, 'changedtick'))

FUNCTION  <SNR>211_HandleExit()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/engine.vim line 151
Called 1 time
Total time:   0.013644
 Self time:   0.000051

count  total (s)   self (s)
    1              0.000003     let l:buffer_info = get(g:ale_buffer_info, a:buffer)
                            
    1              0.000001     if empty(l:buffer_info)
                                    return
    1              0.000000     endif
                            
    1              0.000001     let l:linter = a:job_info.linter
    1              0.000002     let l:executable = a:job_info.executable
                            
                                " Remove this job from the list.
    1   0.000011   0.000006     call ale#engine#MarkLinterInactive(l:buffer_info, l:linter.name)
                            
                                " Stop here if we land in the handle for a job completing if we're in
                                " a sandbox.
    1   0.000021   0.000003     if ale#util#InSandbox()
                                    return
    1              0.000000     endif
                            
    1              0.000008     if has('nvim') && !empty(a:output) && empty(a:output[-1])
                                    call remove(a:output, -1)
    1              0.000000     endif
                            
    1              0.000000     try
    1   0.001541   0.000009         let l:loclist = ale#util#GetFunction(l:linter.callback)(a:buffer, a:output)
                                " Handle the function being unknown, or being deleted.
                                catch /E700/
                                    let l:loclist = []
    1              0.000000     endtry
                            
    1   0.012046   0.000008     call ale#engine#HandleLoclist(l:linter.name, a:buffer, l:loclist, 0)

FUNCTION  ale#history#Add()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/history.vim line 12
Called 40 times
Total time:   0.001117
 Self time:   0.001117

count  total (s)   self (s)
   40              0.000063     if g:ale_max_buffer_history_size <= 0
                                    " Don't save anything if the history isn't a positive number.
                                    call setbufvar(a:buffer, 'ale_history', [])
                            
                                    return
   40              0.000018     endif
                            
   40              0.000191     let l:history = getbufvar(a:buffer, 'ale_history', [])
                            
                                " Remove the first item if we hit the max history size.
   40              0.000092     if len(l:history) >= g:ale_max_buffer_history_size
   25              0.000104         let l:history = l:history[1:]
   40              0.000013     endif
                            
   40              0.000196     call add(l:history, {   'status': a:status,   'job_id': a:job_id,   'command': a:command,})
                            
   40              0.000176     call setbufvar(a:buffer, 'ale_history', l:history)

FUNCTION  ale#util#JoinNeovimOutput()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/util.vim line 59
Called 41 times
Total time:   0.001298
 Self time:   0.001294

count  total (s)   self (s)
   41              0.000084     if a:mode is# 'raw'
                                    call a:callback(a:job, join(a:data, "\n"))
                            
                                    return ''
   41              0.000020     endif
                            
   41              0.000150     let l:lines = a:data[:-2]
                            
   41              0.000092     if len(a:data) > 1
    1              0.000004         let l:lines[0] = a:last_line . l:lines[0]
    1              0.000001         let l:new_last_line = a:data[-1]
   40              0.000021     else
   40              0.000140         let l:new_last_line = a:last_line . get(a:data, 0, '')
   41              0.000031     endif
                            
   42              0.000078     for l:line in l:lines
    1   0.000010   0.000006         call a:callback(a:job, l:line)
   42              0.000034     endfor
                            
   41              0.000050     return l:new_last_line

FUNCTION  <SNR>212_ExitCallback()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/command.vim line 285
Called 20 times
Total time:   0.013983
 Self time:   0.000264

count  total (s)   self (s)
   20              0.000056     if !has_key(s:buffer_data, a:buffer)
                                    return
   20              0.000007     endif
                            
   20              0.000045     let l:jobs = s:buffer_data[a:buffer].jobs
                            
   20              0.000033     if !has_key(l:jobs, a:data.job_id)
   19              0.000010         return
    1              0.000000     endif
                            
    1              0.000003     let l:job_type = remove(l:jobs, a:data.job_id)
                            
    1              0.000001     if g:ale_history_enabled
    1   0.000038   0.000007         call ale#history#SetExitCode(a:buffer, a:data.job_id, a:data.exit_code)
                            
                                    " Log the output of the command for ALEInfo if we should.
    1              0.000002         if g:ale_history_log_output && a:data.log_output is 1
    1   0.000035   0.000009             call ale#history#RememberOutput(   a:buffer,   a:data.job_id,   a:line_list[:])
    1              0.000000         endif
    1              0.000000     endif
                            
                                " If the callback starts any new jobs, use the same job type for them.
    1              0.000003     call setbufvar(a:buffer, 'ale_job_type', l:job_type)
    1   0.013661   0.000017     let l:value = a:Callback(a:buffer, a:line_list, {   'exit_code': a:data.exit_code,   'temporary_file': a:data.temporary_file,})
                            
    1              0.000001     let l:result = a:data.result
    1              0.000002     let l:result.value = l:value
                            
                                " Set the default cwd for this buffer in this call stack.
    1   0.000022   0.000009     call ale#command#SetCwd(a:buffer, l:result.cwd)
                            
    1              0.000000     try
    1              0.000002         if get(l:result, 'result_callback', v:null) isnot v:null
                                        call call(l:result.result_callback, [l:value])
    1              0.000000         endif
    1              0.000000     finally
    1   0.000008   0.000004         call ale#command#ResetCwd(a:buffer)
    1              0.000001     endtry

FUNCTION  <SNR>40_ClearCache()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic.vim line 447
Called 3 times
Total time:   0.000713
 Self time:   0.000042

count  total (s)   self (s)
    3   0.000070   0.000013     let loclist = g:SyntasticLoclist.current(a:buf)
    3   0.000521   0.000015     call s:notifiers.reset(loclist)
    3   0.000121   0.000012     call loclist.destroy()

FUNCTION  <SNR>260_SetListsImpl()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/list.vim line 84
Called 1 time
Total time:   0.004155
 Self time:   0.003071

count  total (s)   self (s)
    1              0.002942     let l:title = expand('#' . a:buffer . ':p')
                            
    1              0.000003     if g:ale_set_quickfix
                                    let l:quickfix_list = ale#list#GetCombinedList()
                            
                                    if has('nvim')
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list), ' ', l:title)
                                    else
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list))
                                        call setqflist([], 'r', {'title': l:title})
                                    endif
    1              0.000001     elseif g:ale_set_loclist
                                    " If windows support is off, win_findbuf() may not exist.
                                    " We'll set result in the current window, which might not be correct,
                                    " but it's better than nothing.
    1   0.000017   0.000010         let l:ids = s:WinFindBuf(a:buffer)
                            
    2              0.000003         for l:id in l:ids
    1              0.000003             if has('nvim')
    1   0.001061   0.000031                 call setloclist(l:id, s:FixList(a:buffer, a:loclist), ' ', l:title)
                                        else
                                            call setloclist(l:id, s:FixList(a:buffer, a:loclist))
                                            call setloclist(l:id, [], 'r', {'title': l:title})
    1              0.000000             endif
    2              0.000001         endfor
    1              0.000000     endif
                            
                                " Save the current view before opening/closing any window
    1              0.000004     call setbufvar(a:buffer, 'ale_winview', winsaveview())
                            
                                " Open a window to show the problems if we need to.
                                "
                                " We'll check if the current buffer's List is not empty here, so the
                                " window will only be opened if the current buffer has problems.
    1   0.000026   0.000011     if s:ShouldOpen(a:buffer) && !empty(a:loclist)
                                    let l:winnr = winnr()
                                    let l:mode = mode()
                            
                                    " open windows vertically instead of default horizontally
                                    let l:open_type = ''
                            
                                    if ale#Var(a:buffer, 'list_vertical') == 1
                                        let l:open_type = 'vert rightbelow '
                                    endif
                            
                                    if g:ale_set_quickfix
                                        if !ale#list#IsQuickfixOpen()
                                            silent! execute l:open_type . 'copen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                        endif
                                    elseif g:ale_set_loclist
                                        silent! execute l:open_type . 'lopen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                    endif
                            
                                    " If focus changed, restore it (jump to the last window).
                                    if l:winnr isnot# winnr()
                                        wincmd p
                                    endif
                            
                                    " Return to original mode when applicable
                                    if mode() != l:mode
                                        if l:mode is? 'v' || l:mode is# "\<c-v>"
                                            " Reset our last visual selection
                                            normal! gv
                                        elseif l:mode is? 's' || l:mode is# "\<c-s>"
                                            " Reset our last character selection
                                            normal! "\<c-g>"
                                        endif
                                    endif
                            
                                    call s:RestoreViewIfNeeded(a:buffer)
    1              0.000000     endif
                            
                                " If ALE isn't currently checking for more problems, close the window if
                                " needed now. This check happens inside of this timer function, so
                                " the window can be closed reliably.
    1   0.000011   0.000005     if !ale#engine#IsCheckingBuffer(a:buffer)
    1   0.000031   0.000005         call s:CloseWindowIfNeeded(a:buffer)
    1              0.000000     endif

FUNCTION  coc#float#nvim_refresh_scrollbar()
    Defined: ~/.config/nvim/plugged/coc.nvim/autoload/coc/float.vim line 769
Called 25 times
Total time:   0.001199
 Self time:   0.000601

count  total (s)   self (s)
   25   0.001008   0.000410   let id = coc#float#get_related(a:winid, 'scrollbar')
   25              0.000074   if id && nvim_win_is_valid(id)
                                call coc#float#nvim_scrollbar(a:winid)
   25              0.000019   endif

FUNCTION  ale#linter#GetExecutable()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/linter.vim line 424
Called 40 times
Total time:   1.243982
 Self time:   0.000522

count  total (s)   self (s)
   40              0.000125     let l:Executable = a:linter.executable
                            
   40   1.243819   0.000359     return type(l:Executable) is v:t_func   ? l:Executable(a:buffer)   : l:Executable

FUNCTION  46()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/loclist.vim line 76
Called 6 times
Total time:   0.000159
 Self time:   0.000053

count  total (s)   self (s)
    6   0.000156   0.000050     return syntastic#util#unique(map(copy(self._rawLoclist), 'str2nr(v:val["bufnr"])') + [self._owner])

FUNCTION  <SNR>253_is_jsx_expression()
    Defined: ~/.config/nvim/plugged/vim-polyglot/autoload/jsx_pretty/indent.vim line 76
Called 4 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    4              0.000013   return a:syntax =~? 'jsxExpressionBlock'

FUNCTION  ale#job#PrepareCommand()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/job.vim line 175
Called 20 times
Total time:   0.000983
 Self time:   0.000804

count  total (s)   self (s)
   20   0.000273   0.000094     let l:wrapper = ale#Var(a:buffer, 'command_wrapper')
                            
                                " The command will be executed in a subshell. This fixes a number of
                                " issues, including reading the PATH variables correctly, %PATHEXT%
                                " expansion on Windows, etc.
                                "
                                " NeoVim handles this issue automatically if the command is a String,
                                " but we'll do this explicitly, so we use the same exact command for both
                                " versions.
   20              0.000070     let l:command = !empty(l:wrapper) ? s:PrepareWrappedCommand(l:wrapper, a:command) : a:command
                            
                                " If a custom shell is specified, use that.
   20              0.000032     if exists('g:ale_shell')
                                    let l:shell_arguments = get(g:, 'ale_shell_arguments', &shellcmdflag)
                            
                                    return split(g:ale_shell) + split(l:shell_arguments) + [l:command]
   20              0.000010     endif
                            
   20              0.000052     if has('win32')
                                    return 'cmd /s/c "' . l:command . '"'
   20              0.000006     endif
                            
   20              0.000104     if &shell =~? 'fish$\|pwsh$'
                                    return ['/bin/sh', '-c', l:command]
   20              0.000006     endif
                            
   20              0.000202     return split(&shell) + split(&shellcmdflag) + [l:command]

FUNCTION  ale#util#GetFunction()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/util.vim line 87
Called 62 times
Total time:   0.000573
 Self time:   0.000573

count  total (s)   self (s)
   62              0.000223     if type(a:string_or_ref) is v:t_string
    1              0.000002         return function(a:string_or_ref)
   61              0.000033     endif
                            
   61              0.000130     return a:string_or_ref

FUNCTION  ale#linter#RemoveIgnored()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/linter.vim line 413
Called 20 times
Total time:   0.000818
 Self time:   0.000429

count  total (s)   self (s)
                                " Apply ignore lists for linters only if needed.
   20   0.000339   0.000122     let l:ignore_config = ale#Var(a:buffer, 'linters_ignore')
   20   0.000307   0.000135     let l:disable_lsp = ale#Var(a:buffer, 'disable_lsp')
                            
   20              0.000128     return !empty(l:ignore_config) || l:disable_lsp   ? ale#engine#ignore#Exclude(a:filetype, a:linters, l:ignore_config, l:disable_lsp)   : a:linters

FUNCTION  54()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/loclist.vim line 170
Called 3 times
Total time:   0.000200
 Self time:   0.000055

count  total (s)   self (s)
    3   0.000082   0.000014     let self._stamp = syntastic#util#stamp()
    6   0.000096   0.000019     for buf in self.getBuffers()
    3              0.000010         call setbufvar(buf, 'syntastic_loclist', self)
    6              0.000003     endfor

FUNCTION  <SNR>38__normalise_filetype()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/registry.vim line 400
Called 6 times
Total time:   0.000069
 Self time:   0.000069

count  total (s)   self (s)
    6              0.000022     let ft = get(s:_DEFAULT_FILETYPE_MAP, a:ftalias, a:ftalias)
    6              0.000013     let ft = get(g:syntastic_filetype_map, ft, ft)
    6              0.000022     let ft = substitute(ft, '\m-', '_', 'g')
    6              0.000005     return ft

FUNCTION  ale#util#Tempname()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/util.vim line 300
Called 20 times
Total time:   0.000375
 Self time:   0.000375

count  total (s)   self (s)
   20              0.000027     let l:clear_tempdir = 0
                            
   20              0.000121     if exists('$TMPDIR') && empty($TMPDIR)
                                    let l:clear_tempdir = 1
                                    let $TMPDIR = '/tmp'
   20              0.000006     endif
                            
   20              0.000016     try
   20              0.000046         let l:name = tempname() " no-custom-checks
   20              0.000022     finally
   20              0.000016         if l:clear_tempdir
                                        let $TMPDIR = ''
   20              0.000007         endif
   20              0.000018     endtry
                            
   20              0.000017     return l:name

FUNCTION  ale#lsp_linter#CheckWithLSP()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/lsp_linter.vim line 450
Called 20 times
Total time:   1.122169
 Self time:   0.000303

count  total (s)   self (s)
   20   1.122161   0.000295     return ale#lsp_linter#StartLSP(a:buffer, a:linter, function('s:CheckWithLSP'))

FUNCTION  coc#rpc#notify()
    Defined: ~/.config/nvim/plugged/coc.nvim/autoload/coc/rpc.vim line 95
Called 113 times
Total time:   0.013985
 Self time:   0.002171

count  total (s)   self (s)
  113   0.001730   0.000699   if !coc#rpc#ready()
                                return ''
  113              0.000061   endif
  113   0.011899   0.001116   call s:client['notify'](a:method, a:args)
  113              0.000116   return ''

FUNCTION  <SNR>218_NeoVimCallback()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/job.vim line 29
Called 61 times
Total time:   0.019633
 Self time:   0.003417

count  total (s)   self (s)
   61              0.000317     let l:info = s:job_map[a:job]
                            
   61              0.000114     if a:event is# 'stdout'
   21   0.001583   0.000541         let l:info.out_cb_line = ale#util#JoinNeovimOutput(   a:job,   l:info.out_cb_line,   a:data,   l:info.mode,   ale#util#GetFunction(l:info.out_cb),)
   40              0.000050     elseif a:event is# 'stderr'
   20   0.001079   0.000380         let l:info.err_cb_line = ale#util#JoinNeovimOutput(   a:job,   l:info.err_cb_line,   a:data,   l:info.mode,   ale#util#GetFunction(l:info.err_cb),)
   20              0.000011     else
   20              0.000060         if has_key(l:info, 'out_cb') && !empty(l:info.out_cb_line)
                                        call ale#util#GetFunction(l:info.out_cb)(a:job, l:info.out_cb_line)
   20              0.000010         endif
                            
   20              0.000044         if has_key(l:info, 'err_cb') && !empty(l:info.err_cb_line)
                                        call ale#util#GetFunction(l:info.err_cb)(a:job, l:info.err_cb_line)
   20              0.000007         endif
                            
   20              0.000011         try
   20   0.014730   0.000257             call ale#util#GetFunction(l:info.exit_cb)(a:job, a:data)
   20              0.000015         finally
                                        " Automatically forget about the job after it's done.
   20              0.000033             if has_key(s:job_map, a:job)
   20              0.000053                 call remove(s:job_map, a:job)
   20              0.000008             endif
   20              0.000013         endtry
   61              0.000025     endif

FUNCTION  <SNR>211_RunJob()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/engine.vim line 401
Called 20 times
Total time:   0.075198
 Self time:   0.001487

count  total (s)   self (s)
   20   0.000170   0.000099     if ale#command#IsDeferred(a:command)
                                    let a:command.result_callback = {   command -> s:RunJob(command, a:options)}
                            
                                    return 1
   20              0.000007     endif
                            
   20              0.000023     let l:command = a:command
                            
   20              0.000024     if empty(l:command)
                                    return 0
   20              0.000006     endif
                            
   20              0.000025     let l:cwd = a:options.cwd
   20              0.000025     let l:executable = a:options.executable
   20              0.000021     let l:buffer = a:options.buffer
   20              0.000019     let l:linter = a:options.linter
   20              0.000023     let l:output_stream = a:options.output_stream
   20              0.000031     let l:read_buffer = a:options.read_buffer && !a:options.lint_file
   20              0.000044     let l:info = g:ale_buffer_info[l:buffer]
                            
   20              0.000167     let l:Callback = function('s:HandleExit', [{   'linter': l:linter,   'executable': l:executable,}])
   20   0.073699   0.000326     let l:result = ale#command#Run(l:buffer, l:command, l:Callback, {   'cwd': l:cwd,   'output_stream': l:output_stream,   'executable': l:executable,   'read_buffer': l:read_buffer,   'log_output': 1,   'filename_mappings': ale#GetFilenameMappings(l:buffer, l:linter.name),})
                            
                                " Only proceed if the job is being run.
   20              0.000041     if empty(l:result)
                                    return 0
   20              0.000006     endif
                            
   20   0.000459   0.000215     call ale#engine#MarkLinterActive(l:info, l:linter)
                            
   20   0.000188   0.000165     silent doautocmd <nomodeline> User ALEJobStarted
                            
   20              0.000035     return 1

FUNCTION  <SNR>40__skip_file()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic.vim line 730
Called 7 times
Total time:   0.031818
 Self time:   0.016643

count  total (s)   self (s)
    7              0.000014     let fname = bufname(a:buf)
    7   0.031749   0.016582     let skip = s:_is_quitting(a:buf) || getbufvar(a:buf, 'syntastic_skip_checks') || (getbufvar(a:buf, '&buftype') !=# '') || !filereadable(fname) || getwinvar(0, '&diff') || getwinvar(0, '&previewwindow') || s:_ignore_file(fname) || fnamemodify(fname, ':e') =~? g:syntastic_ignore_extensions
    7              0.000007     if skip
    1   0.000013   0.000005         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, '_skip_file: skipping checks')
    7              0.000003     endif
    7              0.000006     return skip

FUNCTION  ale#command#RemoveManagedFiles()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/command.vim line 83
Called 1 time
Total time:   0.001025
 Self time:   0.001017

count  total (s)   self (s)
    1              0.000003     let l:info = get(s:buffer_data, a:buffer, {})
                            
    1              0.000002     if !empty(l:info) && empty(l:info.jobs)
                                    " We can't delete anything in a sandbox, so wait until we escape from
                                    " it to delete temporary files and directories.
    1   0.000013   0.000005         if ale#util#InSandbox()
                                        return
    1              0.000000         endif
                            
                                    " Delete files with a call akin to a plan `rm` command.
    1              0.000002         for l:filename in l:info.file_list
                                        call delete(l:filename)
    1              0.000001         endfor
                            
                                    " Delete directories like `rm -rf`.
                                    " Directories are handled differently from files, so paths that are
                                    " intended to be single files can be set up for automatic deletion
                                    " without accidentally deleting entire directories.
   21              0.000019         for l:directory in l:info.directory_list
   20              0.000957             call delete(l:directory, 'rf')
   21              0.000017         endfor
                            
    1              0.000003         call remove(s:buffer_data, a:buffer)
    1              0.000000     endif

FUNCTION  ale#linter#GetCwd()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/linter.vim line 432
Called 20 times
Total time:   0.808087
 Self time:   0.000228

count  total (s)   self (s)
   20              0.000063     let l:Cwd = get(a:linter, 'cwd', v:null)
                            
   20   0.808010   0.000151     return type(l:Cwd) is v:t_func ? l:Cwd(a:buffer) : l:Cwd

FUNCTION  <SNR>71_AlternatePair()
    Defined: ~/.config/nvim/plugged/vim-polyglot/indent/javascript.vim line 137
Called 1 time
Total time:   0.008189
 Self time:   0.000104

count  total (s)   self (s)
    1              0.000002   let [pat, l:for] = ['[][(){};]', 2]
    4   0.005041   0.000022   while s:SearchLoop(pat,'bW','s:SkipFunc()')
    4   0.000034   0.000023     if s:LookingAt() == ';'
    2              0.000002       if !l:for
                                    if s:GetPair('{','}','bW','s:SkipFunc()')
                                      return
                                    endif
                                    break
    2              0.000001       else
    2              0.000004         let [pat, l:for] = ['[{}();]', l:for - 1]
    2              0.000001       endif
    2              0.000001     else
    2   0.000012   0.000009       let idx = stridx('])}',s:LookingAt())
    2              0.000002       if idx == -1
    1              0.000001         return
    1   0.003058   0.000006       elseif !s:GetPair(['\[','(','{'][idx],'])}'[idx],'bW','s:SkipFunc()')
                                    break
    1              0.000000       endif
    3              0.000001     endif
    3              0.000002   endwhile
                              throw 'out of bounds'

FUNCTION  SyntasticStatuslineFlag()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic.vim line 697
Called 204 times
Total time:   0.021865
 Self time:   0.002950

count  total (s)   self (s)
  204   0.021685   0.002769     return g:SyntasticLoclist.current().getStatuslineFlag()

FUNCTION  <SNR>260_CloseWindowIfNeeded()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/list.vim line 207
Called 1 time
Total time:   0.000026
 Self time:   0.000007

count  total (s)   self (s)
    1   0.000025   0.000006     if ale#Var(a:buffer, 'keep_list_window_open') || !s:ShouldOpen(a:buffer)
    1              0.000000         return
                                endif
                            
                                let l:did_close_any_list = 0
                            
                                try
                                    " Only close windows if the quickfix list or loclist is completely empty,
                                    " including errors set through other means.
                                    if g:ale_set_quickfix
                                        if empty(getqflist())
                                            cclose
                                            let l:did_close_any_list = 1
                                        endif
                                    else
                                        let l:win_ids = s:WinFindBuf(a:buffer)
                            
                                        for l:win_id in l:win_ids
                                            if g:ale_set_loclist && empty(getloclist(l:win_id))
                                                lclose
                                                let l:did_close_any_list = 1
                                            endif
                                        endfor
                                    endif
                                " Ignore 'Cannot close last window' errors.
                                catch /E444/
                                endtry
                            
                                if l:did_close_any_list
                                    call s:RestoreViewIfNeeded(a:buffer)
                                endif

FUNCTION  GetJavascriptIndent()
    Defined: ~/.config/nvim/plugged/vim-polyglot/indent/javascript.vim line 350
Called 1 time
Total time:   0.008971
 Self time:   0.000624

count  total (s)   self (s)
    1   0.000016   0.000005   call s:GetVars()
    1              0.000004   let s:synid_cache = [[],[]]
    1              0.000002   let l:line = getline(v:lnum)
                              " use synstack as it validates syn state and works in an empty line
    1              0.000387   let s:stack = [''] + map(synstack(v:lnum,1),"synIDattr(v:val,'name')")
                            
                              " start with strings,comments,etc.
    1              0.000006   if s:stack[-1] =~? 'comment\|doc'
                                if l:line !~ '^\s*\/[/*]'
                                  return l:line =~ '^\s*\*' ? cindent(v:lnum) : -1
                                endif
    1              0.000005   elseif s:stack[-1] =~? b:syng_str
                                if b:js_cache[0] == v:lnum - 1 && s:Balanced(v:lnum-1,getline(v:lnum-1))
                                  let b:js_cache[0] = v:lnum
                                endif
                                return -1
    1              0.000000   endif
                            
    1              0.000003   let nest = get(get(b:,'hi_indent',{}),'blocklnr')
    1              0.000004   let s:l1 = max([0, prevnonblank(v:lnum) - (s:rel ? 2000 : 1000), nest])
    1              0.000002   call cursor(v:lnum,1)
    1   0.000069   0.000008   if s:PreviousToken() is ''
                                return
    1              0.000000   endif
    1              0.000005   let [l:lnum, lcol, pline] = getpos('.')[1:2] + [getline('.')[:col('.')-1]]
                            
    1              0.000005   let l:line = substitute(l:line,'^\s*','','')
    1              0.000001   let l:line_s = l:line[0]
    1              0.000001   if l:line[:1] == '/*'
                                let l:line = substitute(l:line,'^\%(\/\*.\{-}\*\/\s*\)*','','')
    1              0.000000   endif
    1              0.000002   if l:line =~ '^\/[/*]'
                                let l:line = ''
    1              0.000000   endif
                            
                              " the containing paren, bracket, or curly. Many hacks for performance
    1              0.000002   call cursor(v:lnum,1)
    1              0.000003   let idx = index([']',')','}'],l:line[0])
    1              0.000004   if b:js_cache[0] > l:lnum && b:js_cache[0] < v:lnum || b:js_cache[0] == l:lnum && s:Balanced(l:lnum,pline)
                                call call('cursor',b:js_cache[1:])
    1              0.000000   else
    1              0.000021     let [s:looksyn, s:top_col, s:check_in, s:l1] = [v:lnum - 1,0,0, max([s:l1, &smc ? search('\m^.\{'.&smc.',}','nbW',s:l1 + 1) + 1 : 0])]
    1              0.000001     try
    1              0.000001       if idx != -1
                                    call s:GetPair(['\[','(','{'][idx],'])}'[idx],'bW','s:SkipFunc()')
    1              0.000007       elseif getline(v:lnum) !~ '^\S' && s:stack[-1] =~? 'block\|^jsobject$'
                                    if !s:GetPair('{','}','bW','s:SkipFunc()') && s:stack[-1] ==# 'jsObject'
                                      return indent(l:lnum)
                                    endif
    1              0.000000       else
    1   0.008197   0.000008         call s:AlternatePair()
    1              0.000000       endif
                                catch /^\Cout of bounds$/
                                  call cursor(v:lnum,1)
    1              0.000001     endtry
    1              0.000004     let b:js_cache[1:] = line('.') == v:lnum ? [0,0] : getpos('.')[1:2]
    1              0.000000   endif
                            
    1              0.000003   let [b:js_cache[0], num] = [v:lnum, b:js_cache[1]]
                            
    1   0.000012   0.000010   let [num_ind, is_op, b_l, l:switch_offset, s:in_jsx] = [s:Nat(indent(num)),0,0,0,0]
    1   0.000088   0.000010   if !num || s:LookingAt() == '{' && s:IsBlock()
    1              0.000001     let ilnum = line('.')
    1   0.000007   0.000005     if num && !s:in_jsx && s:LookingAt() == ')' && s:GetPair('(',')','bW',s:skip_expr)
                                  if ilnum == num
                                    let [num, num_ind] = [line('.'), indent('.')]
                                  endif
                                  if idx == -1 && s:PreviousToken() ==# 'switch' && s:IsSwitch()
                                    let l:switch_offset = &cino !~ ':' ? s:sw() : s:ParseCino(':')
                                    if pline[-1:] != '.' && l:line =~# '^\%(default\|case\)\>'
                                      return s:Nat(num_ind + l:switch_offset)
                                    elseif &cino =~ '='
                                      let l:case_offset = s:ParseCino('=')
                                    endif
                                  endif
    1              0.000000     endif
    1              0.000005     if idx == -1 && pline[-1:] !~ '[{;]'
                                  call cursor(l:lnum, lcol)
                                  let sol = matchstr(l:line,s:opfirst)
                                  if sol is '' || sol == '/' && s:SynAt(v:lnum, 1 + len(getline(v:lnum)) - len(l:line)) =~? 'regex'
                                    if s:Continues()
                                      let is_op = s:sw()
                                    endif
                                  elseif num && sol =~# '^\%(in\%(stanceof\)\=\|\*\)$' && s:LookingAt() == '}' && s:GetPair('{','}','bW',s:skip_expr) && s:PreviousToken() == ')' && s:GetPair('(',')','bW',s:skip_expr) && (s:PreviousToken() == ']' || s:LookingAt() =~ '\k' && s:{s:PreviousToken() == '*' ? 'Previous' : ''}Token() !=# 'function')
                                    return num_ind + s:sw()
                                  else
                                    let is_op = s:sw()
                                  endif
                                  call cursor(l:lnum, lcol)
                                  let b_l = s:Nat(s:IsContOne(is_op) - (!is_op && l:line =~ '^{')) * s:sw()
    1              0.000000     endif
                              elseif idx == -1 && s:LookingAt() == '(' && &cino =~ '(' && (search('\m\S','nbW',num) || s:ParseCino('U'))
                                let pval = s:ParseCino('(')
                                if !pval
                                  let [Wval, vcol] = [s:ParseCino('W'), virtcol('.')]
                                  if search('\m'.get(g:,'javascript_indent_W_pat','\S'),'W',num)
                                    return s:ParseCino('w') ? vcol : virtcol('.')-1
                                  endif
                                  return Wval ? s:Nat(num_ind + Wval) : vcol
                                endif
                                return s:Nat(num_ind + pval + searchpair('\m(','','\m)','nbrmW',s:skip_expr,num) * s:sw())
    1              0.000000   endif
                            
                              " main return
    1              0.000003   if l:line =~ '^[])}]\|^|}'
                                if l:line_s == ')'
                                  if s:ParseCino('M')
                                    return indent(l:lnum)
                                  elseif num && &cino =~# 'm' && !s:ParseCino('m')
                                    return virtcol('.') - 1
                                  endif
                                endif
                                return num_ind
    1              0.000001   elseif num
    1   0.000012   0.000009     return s:Nat(num_ind + get(l:,'case_offset',s:sw()) + l:switch_offset + b_l + is_op)
                              elseif nest
                                return indent(nextnonblank(nest+1)) + b_l + is_op
                              endif
                              return b_l + is_op

FUNCTION  ale#command#StopJobs()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/command.vim line 261
Called 23 times
Total time:   0.001934
 Self time:   0.000861

count  total (s)   self (s)
   23              0.000090     let l:info = get(s:buffer_data, a:buffer, {})
                            
   23              0.000035     if !empty(l:info)
   23              0.000027         let l:new_map = {}
                            
   42              0.000138         for [l:job_id, l:job_type] in items(l:info.jobs)
   19              0.000037             let l:job_id = str2nr(l:job_id)
                            
   19              0.000037             if a:job_type is# 'all' || a:job_type is# l:job_type
   19   0.001177   0.000104                 call ale#job#Stop(l:job_id)
                                        else
                                            let l:new_map[l:job_id] = l:job_type
   19              0.000007             endif
   42              0.000032         endfor
                            
   23              0.000058         let l:info.jobs = l:new_map
   23              0.000011     endif

FUNCTION  ale#cursor#EchoCursorWarningWithDelay()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/cursor.vim line 104
Called 39 times
Total time:   0.003171
 Self time:   0.002436

count  total (s)   self (s)
   39              0.000158     let l:buffer = bufnr('')
                            
   39              0.000176     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
   39              0.000023     endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
   39              0.000125     if mode(1) isnot# 'n'
                                    return
   39              0.000019     endif
                            
   39   0.000705   0.000387     call s:StopCursorTimer()
                            
   39              0.000234     let l:pos = getpos('.')[0:2]
                            
   39              0.000105     if !exists('w:last_pos')
                                    let w:last_pos = [0, 0, 0]
   39              0.000019     endif
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should echo something. Otherwise we can end up doing processing
                                " the echo message far too frequently.
   39              0.000083     if l:pos != w:last_pos
   24   0.000705   0.000286         let l:delay = ale#Var(l:buffer, 'echo_delay')
                            
   24              0.000060         let w:last_pos = l:pos
   24              0.000227         let s:cursor_timer = timer_start(   l:delay,   function('ale#cursor#EchoCursorWarning'))
   39              0.000029     endif

FUNCTION  ale#sign#ReadSigns()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/sign.vim line 173
Called 1 time
Total time:   0.000071
 Self time:   0.000065

count  total (s)   self (s)
    1              0.000002     redir => l:output
    1   0.000059   0.000053         silent execute 'sign place ' . s:GroupCmd() . s:PriorityCmd() . ' buffer=' . a:buffer
    1              0.000003     redir end
                            
    1              0.000007     return split(l:output, "\n")

FUNCTION  <SNR>259_GroupCmd()
    Defined: ~/.config/nvim/plugged/ale/autoload/ale/sign.vim line 164
Called 5 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    5              0.000005     if s:supports_sign_groups
    5              0.000004         return ' group=ale '
                                else
                                    return ' '
                                endif

FUNCTION  GetVueIndent()
    Defined: ~/.config/nvim/plugged/vim-polyglot/indent/vue.vim line 47
Called 1 time
Total time:   0.010621
 Self time:   0.000171

count  total (s)   self (s)
    5              0.000016   for language in s:languages
    5              0.000098     let opening_tag_line = searchpair(language.pairs[0], '', language.pairs[1], 'bWr')
                            
    5              0.000004     if opening_tag_line
    1   0.010467   0.000017       execute 'let indent = ' . get(language, 'indentexpr', -1)
    1              0.000001       break
    4              0.000002     endif
    5              0.000003   endfor
                            
    1              0.000002   if exists('l:indent')
    1              0.000010     if (opening_tag_line == prevnonblank(v:lnum - 1) || opening_tag_line == v:lnum) || getline(v:lnum) =~ '\v^\s*\</(script|style|template)'
                                  return 0
    1              0.000000     endif
                              else
                                " Couldn't find language, fall back to html
                                execute 'let indent = ' . s:html_indent
    1              0.000000   endif
                            
    1              0.000001   return indent

FUNCTION  <SNR>197__isDebugEnabled_smart()
    Defined: ~/.config/nvim/plugged/syntastic/autoload/syntastic/log.vim line 149
Called 82 times
Total time:   0.000158
 Self time:   0.000158

count  total (s)   self (s)
   82              0.000137     return and(g:syntastic_debug, a:level)

FUNCTION  <SNR>253_trim()
    Defined: ~/.config/nvim/plugged/vim-polyglot/autoload/jsx_pretty/indent.vim line 20
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000011   return substitute(a:line, '^\s*\|\s*$', '', 'g')

FUNCTION  95()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/signs.vim line 31
Called 3 times
Total time:   0.000256
 Self time:   0.000068

count  total (s)   self (s)
    3   0.000033   0.000012     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'signs: refresh')
                            
    3   0.000024   0.000012     let old_signs = copy(self._bufSignIds())
    3   0.000049   0.000007     if self.enabled()
    3              0.000003         if !s:setup_done
                                        call self._setup()
                                        let s:setup_done = 1
                                        lockvar s:setup_done
    3              0.000001         endif
                            
    3   0.000100   0.000011         call self._signErrors(a:loclist)
    3              0.000001     endif
    3   0.000033   0.000010     call self._removeSigns(old_signs)

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   20   3.702123   0.022558  <SNR>198_Lint()
   20   3.670155   0.000676  ale#engine#RunLinters()
   20   3.668603   0.001721  <SNR>211_GetLintFileValues()
   20   3.666365   0.002041  <SNR>211_RunLinters()
   40   3.659219   0.000879  <SNR>211_RunLinter()
   21   3.495886   0.001035  ale#Queue()
  160   3.233212             ale#path#FindNearestFile()
   80   2.858749   0.002882  ale#node#FindNearestExecutable()
   60   2.053877   0.001521  ale#node#FindExecutable()
   20   1.698273   0.001655  <SNR>211_RunIfExecutable()
   40   1.648568   0.000325  ale#handlers#eslint#GetExecutable()
   40   1.243982   0.000522  ale#linter#GetExecutable()
   20   1.122169   0.000303  ale#lsp_linter#CheckWithLSP()
   20   1.121866   0.001256  ale#lsp_linter#StartLSP()
   20   0.812595   0.000229  ale#linter#GetCommand()
   20   0.812366   0.000596  ale#handlers#eslint#GetCommand()
   20   0.808087   0.000228  ale#linter#GetCwd()
   20   0.807859   0.000570  ale#handlers#eslint#GetCwd()
    4   0.572194   0.000374  ale#events#SaveEvent()
   20   0.405823   0.000189  <lambda>3()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
  160              3.233212  ale#path#FindNearestFile()
   40   0.335329   0.334726  ale#engine#IsExecutable()
   20   0.055945   0.044718  ale#command#FormatCommand()
   11              0.031678  UltiSnips#TrackChange()
   11              0.031516  provider#python3#Call()
   40              0.030223  <SNR>49_Highlight_Matching_Pair()
   20   3.702123   0.022558  <SNR>198_Lint()
    7   0.031818   0.016643  <SNR>40__skip_file()
    6              0.015084  <SNR>40__ignore_file()
   20   0.012353   0.012272  ale#job#Start()
  204              0.011850  48()
  113   0.010783   0.010161  <SNR>20_notify()
    5              0.009966  syntastic#util#fname2buf()
    2              0.007660  coc#util#get_complete_option()
    3              0.007593  <SNR>71_SynAt()
    4   0.007403   0.007385  <SNR>20_request()
   20              0.006778  ale#util#Writefile()
   28   0.006324   0.006229  ale#cursor#TruncatedEcho()
   20   0.008570   0.005726  ale#linter#Get()
  210   0.007174   0.005575  39()

